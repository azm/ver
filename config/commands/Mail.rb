# Encoding: UTF-8

[{beforeRunningCommand: "nop",
  command: "${TM_RUBY:-ruby} -e 'print STDIN.read.unpack(\"m*\")[0]'",
  fallbackInput: "line",
  input: "selection",
  name: "Decode Base 64 Line / Selection",
  output: "replaceSelectedText",
  uuid: "19A73EFD-E8D2-44D1-A3ED-EF604BB290EF"},
 {beforeRunningCommand: "nop",
  command: 
   "#!/usr/bin/env ruby -wKU\nprint STDIN.read.gsub(/=\\n/, '').gsub(/=([0-9A-F]{2})/) { $1.to_i(16).chr }\n",
  input: "selection",
  name: "Decode Quoted Printables",
  output: "replaceSelectedText",
  uuid: "C0DD4A50-F63F-444F-8661-98FAEC220F51"},
 {beforeRunningCommand: "nop",
  command: "perl -pe 's/^> (.*)/$1/'",
  fallbackInput: "line",
  input: "selection",
  keyEquivalent: "~@'",
  name: "Decrease Quote Level for Line / Selection",
  output: "replaceSelectedText",
  uuid: "B0F37DAC-6E52-11D9-AA12-000D93589AF6"},
 {beforeRunningCommand: "nop",
  command: "${TM_RUBY:-ruby} -e 'print STDIN.read.to_a.pack(\"m*\")'",
  fallbackInput: "line",
  input: "selection",
  name: "Encode Base 64 Line / Selection",
  output: "replaceSelectedText",
  uuid: "3E70551A-26B8-44FD-9D3F-25954E4ECDE4"},
 {beforeRunningCommand: "nop",
  command: "perl -pe 's/(.*)/> $1/'",
  fallbackInput: "line",
  input: "selection",
  keyEquivalent: "@'",
  name: "Increase Quote Level for Line / Selection",
  output: "replaceSelectedText",
  uuid: "9FEC1836-6E52-11D9-AA12-000D93589AF6"},
 {beforeRunningCommand: "nop",
  command: "require_cmd par\n\nPARINIT=\"rTbgqR B=.,?!_A_a Q=_s>|+\" par",
  fallbackInput: "scope",
  input: "selection",
  keyEquivalent: "^q",
  name: "Reformat Quoted Text",
  output: "replaceSelectedText",
  scope: "markup.quote",
  uuid: "65C64E73-D308-4251-9837-A3A040D5704B"},
 {beforeRunningCommand: "nop",
  command: "tr 'A-Za-z' 'N-ZA-Mn-za-m'",
  fallbackInput: "line",
  input: "selection",
  name: "Rot 13 Line / Selection",
  output: "replaceSelectedText",
  uuid: "44B4C1CE-DD85-485A-B860-E4DFCDD0A4FE"},
 {beforeRunningCommand: "nop",
  command: 
   "# This requires that 'enable access for assistive devices' is enabled\n\n# Create a temporary file so that this works with unsaved documents\nTM_TMPFILE=\"$(mktemp /tmp/tm_mail_XXXXXX).html\" || exit\n\n# Create a title based on the filename, if there is one\nTM_TITLE=${TM_FILENAME:-untitled}\n\ncat   >\"$TM_TMPFILE\"\necho >>\"$TM_TMPFILE\" \"<title>${TM_TITLE%.*}</title>\"\n\nosascript -e 'tell app \"Safari\" to make new document with properties { URL:\"file://'\"$TM_TMPFILE\"'\" }'\nosascript -e 'tell app \"Safari\"' -e 'email contents of first document' -e 'close first document' -e 'end tell'\n\nrm -f \"$TM_TMPFILE\" \"${TM_TMPFILE%.html}\"",
  input: "document",
  keyEquivalent: "@D",
  name: "Send HTML as Email [With Safari]",
  output: "showAsTooltip",
  scope: "text.html",
  uuid: "B3BF8765-30D5-46E7-8331-860B47CDD348"},
 {beforeRunningCommand: "nop",
  command: 
   "#!/usr/bin/env ruby\n\ndef quote_level (line)\n  /^[> ]*/.match(line.to_s)[0].count \">\"\nend\n\ndef blank_line? (line)\n  line.nil? || line.sub(/^[> ]*/, '').strip.empty?\nend\n\ndef reformat_lines (lines)\n  non_quoted = lines.collect { |line| line.sub(/^[> ]*/, '').strip }\n  indent = /^[> ]*/.match(lines.first.to_s)[0]\n  indent + non_quoted.join(\" \")\nend\n\nlines = STDIN.read.to_a\n\ncur_qlevel = 0\npar_bounds = [ 0 ]\n\nlines.each_with_index do |line, i|\n  if blank_line?(line) then\n    par_bounds << i\n    par_bounds << i+1\n  elsif cur_qlevel != quote_level(line) then\n    par_bounds << i\n  end\n  cur_qlevel = quote_level(line)\nend\n\npar_bounds.uniq!\npar_bounds.each_with_index do |i, idx|\n  j = idx+1 < par_bounds.size ? par_bounds[idx+1] : lines.size\n  puts reformat_lines(lines[i...j])\nend\n",
  input: "selection",
  keyEquivalent: "^Q",
  name: "Unwrap Paragraphs",
  output: "replaceSelectedText",
  scope: "text.mail",
  uuid: "72DCB8FA-2DAF-46D2-A77C-3459EE982EF6"}]
