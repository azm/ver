# Encoding: UTF-8

[{beforeRunningCommand: "nop",
  command: 
   "#!/usr/bin/env ruby\nrequire 'pp'\nrequire ENV[\"TM_SUPPORT_PATH\"] + \"/lib/escape.rb\"\ndata=STDIN.readlines\nl,c = ENV['TM_LINE_NUMBER'].to_i-ENV['TM_INPUT_START_LINE'].to_i, ENV['TM_LINE_INDEX'].to_i\n# pp [l,c]\ncol_no = data[l].slice(/^.{\#{c}}/).scan(\"&\").length\nif col_no == 0 then\n  data.each do |line|\n    if line =~ /&/ then\n      print \" & \" + line\n    else\n      print line\n    end\n  end\nelse\n  data.each do |line|\n    if line =~ /^(?:[^&]*&){\#{col_no}}/ then\n      print $& + \" &\" + $'\n    else\n      print line\n    end\n  end\nend",
  fallbackInput: "scope",
  input: "selection",
  keyEquivalent: "^~",
  name: "Add Column",
  output: "replaceSelectedText",
  scope: "text.tex.latex  meta.data.environment.tabular.latex",
  uuid: "E70BB4A8-2654-4ED3-A187-9BFD024870E7"},
 {beforeRunningCommand: "nop",
  command: 
   "if [[ -z $TM_SELECTED_TEXT ]]\n   then \n# If the cursor is inside empty braces {}, then offer\n# a list of all bibliography items. In that case, \n# the variable $phrase is not being set.\n\tprev_ch=${TM_CURRENT_LINE:$TM_LINE_INDEX-1:1}\n\tif [[ $prev_ch != '{' ]]\n\t\tthen phrase=$TM_CURRENT_WORD\n\tfi\n   else phrase=$TM_SELECTED_TEXT\nfi\nif [[ -z $phrase ]]\n\tthen \n# Case where $phrase is not defined\n\nres=`osascript <<EOF\ntell application \"Bibdesk\"\n\tset publist to get displayed publications of the first item of documents\n\tset candidates to {}\n\t\trepeat with anItem in publist\n\t\tset candidates to candidates & ((cite key of anItem) & \" % \" & (last name of author of anItem) & \", \" & (title of anItem))\n\t\tend repeat\n\tend tell\n\ttell application \"System Events\"\n\t\tactivate\n\t\tchoose from list candidates\n\tend tell\nEOF`\n\telse \n# Case where $phrase is defined\n\nres=`osascript <<EOF\n\ttell application \"Bibdesk\" to set candidates to search for \"$phrase\" with for completion\n\ttell application \"System Events\"\n\t\tactivate\n\t\tchoose from list candidates\n\tend tell\nEOF`\nfi\n# If an error occurs, $? stores the return code.\nerrorcode=$?\n# return control to TextMate\nosascript -e 'tell app \"TextMate\" to activate' &>/dev/null &\n# If user presses Cancel, then applescript returns false. \nif [[ (${res:0:5} == false) || ($errorcode != 0) ]]\n\tthen exit_discard\nfi\n\nres=`perl -pe <<<$res 's/^(.*?)(\\s*)%.*/$1/'` # strip comment\nres=\"${res//\\\\\\\\/\\\\\\\\}\"                       # \\ -> \\\\\nres=\"${res//$/\\\\$}\"                           # $ -> \\$\n\necho -n $res\n#if [[ -z $TM_SELECTED_TEXT ]] && [[ -n $phrase ]]\n#   then echo -n ${res:${#TM_CURRENT_WORD}}\n#   else echo -n ${res}\n#fi\n#",
  fallbackInput: "word",
  input: "selection",
  name: "BibDesk Completion",
  output: "replaceSelectedText",
  scope: "meta.citation.latex",
  uuid: "F80F9C22-ABB8-11D9-957A-000D93589AF6"},
 {beforeRunningCommand: "nop",
  command: "toggle_style.rb -style=textbf",
  fallbackInput: "word",
  input: "selection",
  keyEquivalent: "@b",
  name: "Bold",
  output: "insertAsSnippet",
  scope: "text.tex.latex",
  uuid: "5F0E6093-660C-4018-B664-4264FFA4BDE1"},
 {beforeRunningCommand: "nop",
  command: 
   "#!/usr/bin/env ruby\nrequire ENV['TM_SUPPORT_PATH'] + \"/lib/escape.rb\"\nlines = STDIN.readlines\nfi = lines.shift\nla = lines.pop\nlines.map!{|l| e_sn(l)}\n[fi,la].each do |l| l.sub!(/(\\\\(?:begin|end)\\{)\\w+\\*?\\}/) do |m|\n    \"\#{$1}$1\\}\"\n  end\nend\nl,c = ENV['TM_LINE_NUMBER'].to_i-ENV['TM_INPUT_START_LINE'].to_i, ENV['TM_LINE_INDEX'].to_i-ENV['TM_INPUT_START_LINE_INDEX'].to_i\nlines[l-1].sub!(/^(.{\#{c}})/,\"\\\\1$0\")\nprint [fi,*lines].join(\"\")\nprint la\n",
  fallbackInput: "scope",
  input: "selection",
  keyEquivalent: "^~e",
  name: "Change Current",
  output: "insertAsSnippet",
  scope: "text.tex meta.function.environment",
  uuid: "06BAABEC-B819-4778-94FF-C744CF5DD7CD"},
 {beforeRunningCommand: "nop",
  command: 
   "# Source some support functions we need.\n. \"${TM_SUPPORT_PATH}/lib/html.sh\"\n. \"${TM_SUPPORT_PATH}/lib/webpreview.sh\"\n\n# Prepare output window.\nhtml_header 'ChkTeX' \"$FILE\"\n\ntexMate.py chktex 1\n\nhtml_footer\n",
  input: "none",
  keyEquivalent: "^V",
  name: "Check LaTeX (chktex)",
  output: "showAsHTML",
  scope: "text.tex.latex",
  uuid: "B345876F-1B84-4FF5-A19C-A62ADF121EC8"},
 {beforeRunningCommand: "nop",
  command: 
   "#!/usr/bin/env ruby\n\n# A reftex-style citation command\n\nrequire ENV[\"TM_SUPPORT_PATH\"] + \"/lib/exit_codes.rb\"\nrequire ENV[\"TM_SUPPORT_PATH\"] + \"/lib/ui.rb\"\nrequire ENV[\"TM_BUNDLE_SUPPORT\"] + \"/lib/LaTeXUtils.rb\"\ninclude LaTeX\nphrase = STDIN.read\nscope = String.new(ENV[\"TM_SCOPE\"])\n\nif !(scope.include? \"meta.citation.latex\")\nitems = [\"c:  \\\\cite\",\n\t\t\"t:  \\\\citet\",\n\t\t\"    \\\\citet*\",\n\t\t\"p:  \\\\citep\",\n\t\t\"    \\\\citep*\",\n\t\t\"e:  \\\\citep[e.g.]\",\n\t\t\"s:  \\\\citep[see]\",\n\t\t\"a:  \\\\citeauthor\",\n\t\t\"    \\\\citeauthor*\",\n\t\t\"y:  \\\\citeyear\",\n\t\t\"r:  \\\\citeyearpar\",\n\t\t\"f:  \\\\footcite\"]\n\nif items.length > 1\n\tchoice = TextMate::UI.menu(items)\n\tTextMate.exit_discard if choice.nil?\n\tchoice = items[choice]\nend\ncphrase = choice.slice(/^[^%]+/).strip\n#cphrase = cphrase[4..-1]\ncphrase.gsub! %r{.*\\\\}, \"\"\nend\n\nbegin\n  items = LaTeX.get_citations.map{|i| i.citekey + \"   % \"+i.description}\n  items = items.grep(/\#{phrase}/i) if phrase != \"\"\n  TextMate.exit_discard if items.empty?\n  if items.length > 1\n  \tchoice = TextMate::UI.menu(items)\n  \tTextMate.exit_discard if choice.nil?\n  \tchoice = items[choice]\n  else\n    choice = items[0]\n  end\n  selection = choice.slice(/^[^%]+/).strip\n  if ENV['TM_SCOPE'].match(/citation/) then\n    TextMate.exit_insert_snippet(\"\#{selection}$0\")\n  else\n    TextMate.exit_insert_snippet(\"\\\\\#{cphrase}${1:[$2]}\\{\#{selection}$3\\}$0\")\n  end\nrescue RuntimeError => e\n  TextMate.exit_insert_text(e.message)\nend\n\n",
  fallbackInput: "word",
  input: "selection",
  keyEquivalent: "^{",
  name: "Citation (Ref-TeX Style)",
  output: "insertAsSnippet",
  scope: "text.tex.latex",
  uuid: "0E51AD42-17AD-4507-950B-AB114408B58D"},
 {beforeRunningCommand: "nop",
  command: 
   "#!/usr/bin/env ruby\nrequire ENV[\"TM_SUPPORT_PATH\"] + \"/lib/exit_codes.rb\"\nrequire ENV[\"TM_SUPPORT_PATH\"] + \"/lib/ui.rb\"\nrequire ENV[\"TM_BUNDLE_SUPPORT\"] + \"/lib/LaTeXUtils.rb\"\nphrase = STDIN.read.chomp\ninclude LaTeX\nbegin\n\titems = LaTeX.get_citations.map{|i| i.citekey + \"   % \"+i.description}\n  items = items.grep(/\#{phrase}/) if phrase != \"\"\n  TextMate.exit_discard if items.empty?\n  if items.length > 1\n  \tchoice = TextMate::UI.menu(items)\n  \tTextMate.exit_discard if choice.nil?\n  \tchoice = items[choice]\n  else\n    choice = items[0]\n  end\n  selection = choice.slice(/^[^%]+/).strip\n  if ENV['TM_SCOPE'].match(/citation/) then\n    print selection\n  else\n    TextMate.exit_insert_snippet(\"\\\\\\\\${1:cite}\\{\#{selection}\\}\")\n  end\nrescue RuntimeError => e\n  TextMate.exit_show_tool_tip(e.message)\nend\n",
  fallbackInput: "word",
  input: "selection",
  keyEquivalent: "~",
  name: "Citation Based on Current Word / Selection…",
  output: "replaceSelectedText",
  scope: "text.tex.latex, meta.citation.latex",
  uuid: "65E2109C-4309-4079-BD25-17D8B31F03CD"},
 {beforeRunningCommand: "nop",
  command: 
   "#!/usr/bin/env ruby\nrequire \"\#{ENV['TM_BUNDLE_SUPPORT']}/lib/config_helper.rb\"\n@plist = Config.load\nshortcuts = @plist['commands']\nif ENV['TM_SCOPE'].match('beamer') then\n  shortcuts.update(@plist['commands_beamer'])\nend\nname = STDIN.read\nif (shortcuts.has_key?(name)) then\n  print shortcuts[name]\nelsif name.nil?\n  print \"\\\\${1:cmd}{$2} \"\nelse\n  print \"\\\\\" + name + \"{$1} \"\nend\n",
  fallbackInput: "word",
  input: "selection",
  keyEquivalent: "@}",
  name: "Command Based on Current Word / Selection",
  output: "insertAsSnippet",
  scope: "text.tex.latex",
  uuid: "79EBE164-2318-4563-83E5-F337588AAC73"},
 {beforeRunningCommand: "nop",
  captureFormatString: "$3",
  capturePattern: "^([^:]*):([^:]*):(.*)$",
  command: 
   "#!/usr/bin/env ruby\nrequire ENV[\"TM_SUPPORT_PATH\"] + \"/lib/exit_codes.rb\"\nrequire ENV[\"TM_SUPPORT_PATH\"] + \"/lib/ui.rb\"\n# require ENV[\"TM_BUNDLE_SUPPORT\"] + \"/lib/LaTeXUtils.rb\"\nphrase = STDIN.read.chomp\n# include LaTeX\nbegin\n  items = `\"\#{ENV['TM_SUPPORT_PATH']}\"/bin/LaTeXCommandCompletions.rb`.split(\"\\n\")\n  TextMate.exit_discard if items.empty?\n  if items.length > 1 then\n    choice = TextMate::UI.menu(items)\n    TextMate.exit_discard if choice.nil?\n    choice = items[choice]\n  else\n    choice = items[0]\n  end\n  print choice\nrescue RuntimeError => e\n  TextMate.exit_show_tool_tip(e.message)\nend\n",
  fallbackInput: "word",
  fileCaptureRegister: "1",
  input: "selection",
  keyEquivalent: "~",
  lineCaptureRegister: "2",
  name: "Command Completion",
  output: "replaceSelectedText",
  scope: 
   "text.tex.latex meta.space-after-command.latex, text.tex.latex support.function.general.tex",
  uuid: "97FDB90C-2CEE-439E-8B01-F892B4ED5E5D"},
 {beforeRunningCommand: "nop",
  command: 
   "#!/usr/bin/env ruby\nrequire ENV['TM_SUPPORT_PATH'] +'/lib/escape.rb'\nprint \"\\\\\\\\${1:emph}{\#{if s = ENV['TM_SELECTED_TEXT'] then e_sn(s) else '$2' end}}\"",
  fallbackInput: "word",
  input: "none",
  keyEquivalent: "^W",
  name: "Command — \\command{…}",
  output: "insertAsSnippet",
  scope: "text.tex.latex",
  uuid: "C3C8F3A3-C90E-4DA3-8AB3-DB7BDA73355C"},
 {beforeRunningCommand: "nop",
  command: 
   "#!/usr/bin/env ruby\ndef escape(str)\n  esc_str = str.gsub(/\\t/,\" & \") + \"\\\\\\\\\"\n  esc_str.gsub(/(\\d)E([+-]?)(\\d{1,2})/) do |m|\n    \"\#{$1} $\\\\times 10^{\#{$2 ==\"-\" ? \"-\" : \"\"}\#{$3.to_i}}$\"\n  end\nend\n# First we change all space sequences of length $TM_TAB_SIZE to tabs.\ndata=STDIN.read.strip.gsub(/ {\#{ENV['TM_TAB_SIZE'].to_i}}/,\"\\t\").split(\"\\n\")\nfirst_line = data.shift\ncount=first_line.scan(/\\t/).length+1;\nresult=[\"\\\\begin{tabular}{\#{\"c\" * count}}\"];\nhl = \"\\\\hline\"\nresult << hl << escape(first_line) << hl \nresult += data.map{|line| escape(line.strip)}\nresult << hl << \"\\\\end{tabular}\"\nputs result.join(\"\\n\")",
  input: "selection",
  keyEquivalent: "^@T",
  name: "Convert Selection to Table",
  output: "replaceSelectedText",
  scope: "text.tex.latex",
  uuid: "0D4F5C42-210C-4C03-8378-D92FB5D323AF"},
 {beforeRunningCommand: "nop",
  command: 
   "#!/usr/bin/env ruby\n\nrequire \"\#{ENV['TM_SUPPORT_PATH']}/lib/exit_codes.rb\"\nrequire \"\#{ENV['TM_SUPPORT_PATH']}/lib/ui.rb\"\n\nif ENV.has_key?('TM_SELECTED_TEXT') then\n  result=ENV['TM_SELECTED_TEXT']\nelse\n  result = TextMate::UI.request_string(\n    :title => 'LaTeX Array Creation', \n    :prompt => 'Number of rows and columns:',\n    :default => '6 4',\n    :button1 => 'Create'\n  )\n  TextMate.exit_discard if result.nil?\nend\n# print \"Result: \#{result}\"\nm = /(\\d+)\\D+(\\d+)/.match(result.to_s)\nexit if m.nil?\nrows, columns = m[1].to_i, m[2].to_i\n# print \"Rows: \#{rows}\"\n# print \"Columns: \#{columns}\"\nprint \"\\\\begin{tabular}{\"\ncolumns.times {print(\"c\")}\nputs \"}\"\nputs \"\\\\hline\\n\"\nn=0\nrows.times do |r|\n  (columns-1).times do |c|\n    n+=1\n    print \"${\#{n}:r\#{r+1}c\#{c+1}} & \"\n  end\n  n+=1\n  print \"${\#{n}:r\#{r+1}c\#{columns}}\\\\\\\\\\\\\\\\\\n\"\n  puts \"\\\\hline\\n\"\nend\nputs \"\\\\end{tabular}\"\n",
  input: "none",
  keyEquivalent: "^@T",
  name: "Create Table",
  output: "insertAsSnippet",
  scope: "text.tex.latex",
  uuid: "7190DABA-FE8B-4DC7-9D31-3A727A8647CD"},
 {beforeRunningCommand: "nop",
  command: 
   "# View documentation for Latex package\n# take advantage of the texdoctk index as well as the texdoc catalog directory.\n. \"${TM_SUPPORT_PATH}/lib/html.sh\"\n. \"${TM_SUPPORT_PATH}/lib/webpreview.sh\"\n\nM=${TM_LATEX_MASTER:=$TM_FILEPATH}\nDIR=`dirname \"$M\"`\nFILE=`basename \"$M\"`\n\nTEXDOCTKDB=`kpsewhich --progname=texdoctk --format='other text files' texdoctk.dat`\nexport TEXDOCTKDB\n\nTMTEXMAIN=`kpsewhich --expand-path '$TEXMFMAIN'`\nexport TMTEXMAIN\n\n# May need to add more lines to accomodate different tex distros.\n[ -z $TM_LATEX_DOCBASE ] && TM_LATEX_DOCBASE=`kpsewhich --expand-path '$TEXMFTE'`   # teTeX\n[ -z $TM_LATEX_DOCBASE ] && TM_LATEX_DOCBASE=`kpsewhich --expand-path '$TEXMFTL'`   # gwTeX \n[ -z $TM_LATEX_DOCBASE ] && TM_LATEX_DOCBASE=`kpsewhich --expand-path '$TEXMFDOCDIR'`  # TeXLive\nexport TM_LATEX_DOCBASE\n\nTM_LATEX_HELP_CATALOG=`find $TMTEXMAIN/../ -name entries -print`\nexport TM_LATEX_HELP_CATALOG\n\nTMTEXDOCDIRS=`kpsewhich --expand-path '$TEXDOCS'`\nexport TMTEXDOCDIRS\n\n# Switch to the right directory.\ncd \"$TM_PROJECT_DIRECTORY\"\ncd \"$DIR\"\n\nhtml_header 'Package Documentation'\necho '<p><small>Hint: Cursor on package name shows doc for package.  Otherwise show package doc browser.</small></p>'\nPyTeXdoc.py",
  input: "none",
  keyEquivalent: "^h",
  name: "Documentation for Package",
  output: "showAsHTML",
  scope: "text.tex.latex",
  uuid: "1A12B844-4074-4655-A45C-18AC8D943267"},
 {beforeRunningCommand: "nop",
  command: 
   "AccountFile=\"$HOME/Library/Preferences/com.macromates.textmate.latex_config.plist\"\nif [[ ! -e \"$AccountFile\" ]]; then\n    cat \"$TM_BUNDLE_SUPPORT/latex.config\" > \"$AccountFile\"\nfi\nopen txmt://open?url=file://$AccountFile",
  input: "none",
  name: "Edit Configuration File",
  output: "discard",
  scope: "text.tex.latex",
  uuid: "D10F1CAC-BF1D-456D-B1E5-6AA5E3DD40ED"},
 {beforeRunningCommand: "nop",
  command: 
   "#!/usr/bin/env ruby\nSUPPORT = ENV['TM_BUNDLE_SUPPORT']\nrequire ENV['TM_SUPPORT_PATH'] + '/lib/ui'\nrequire ENV['TM_SUPPORT_PATH'] + '/lib/exit_codes'\nrequire SUPPORT + '/lib/config_helper.rb'\n@plist = Config.load\nshortcuts = @plist['environments']\nlshortcuts = @plist['labeled_environments']\nif ENV['TM_SCOPE'].match('beamer') then\n  shortcuts.update(@plist['environments_beamer'])\n  lshortcuts.update(@plist['labeled_environments_beamer'])\nend\nname = STDIN.read\ncmd = nil\nif name == \"\" then\n  arr = [\"custom…\",nil] + (shortcuts.keys+lshortcuts.keys).sort\n  ind = TextMate::UI.menu(arr)\n  TextMate.exit_discard if ind.nil?\n  if ind == 0 then\n\tname = \"\"\n  else\n     name = arr[ind]\n  end\nend\noptions = Array.new\nfor key in shortcuts.keys do\n  if shortcuts[key]['triggers'].index(name) then\n    options << {:cmd => key, :setting => :no_label, :content => shortcuts[key]['content']}\n  end\nend\nfor key in lshortcuts.keys do\n  if lshortcuts[key]['triggers'].index(name) then\n    options << {:cmd => key, :setting => :label, :content => lshortcuts[key]['content']}\n  end\nend\nopt = case options.length\nwhen 0\n  nil\nwhen 1\n  options[0]\nelse\n  ind = TextMate::UI.menu(options.map { |opt| opt[:cmd] })\n  ind.nil? ? nil : options[ind]\nend\nif !opt.nil? then\n  print \"\\\\begin{\#{opt[:cmd]}}\"\n  print \"\\n\" if opt[:setting] == :no_label\n  print opt[:content] || \"\\t$0\"\n  print \"\\n\\\\end{\#{opt[:cmd]}}\"\nelsif name == \"\"\n  print \"\\\\begin{${1:env}}\\n\\t$0\\n\\\\end{${1:env}}\"\nelse\n  print \"\\\\begin{\#{name}}\\n\\t$0\\n\\\\end{\#{name}}\"\nend\n",
  fallbackInput: "word",
  input: "selection",
  keyEquivalent: "@{",
  name: "Environment Based on Current Word / Selection",
  output: "insertAsSnippet",
  scope: "text.tex.latex",
  uuid: "521C9FC0-0B61-48C8-A76B-60A4AE8DF449"},
 {beforeRunningCommand: "nop",
  command: 
   "# This command inserts any missing \\end{environment} at the caret position\n# It is analogous with Insert Closing Tag for HTML.\n\nruby -- \"$TM_SUPPORT_PATH/bin/checknest.rb\" '\\\\begin(?>\\{(.+?)\\})' '\\\\end(?>\\{(.+?)\\})' '\\end{$1}' -n$TM_LINE_NUMBER",
  input: "document",
  keyEquivalent: "~@.",
  name: "Environment Closer — \\end{…}",
  output: "afterSelectedText",
  scope: "text.tex.latex",
  uuid: "D52CA669-A6DA-4CF1-BDF5-522D591D7E7D"},
 {beforeRunningCommand: "nop",
  command: 
   ". \"$TM_SUPPORT_PATH/lib/webpreview.sh\"\nhtml_header \"LaTeX Bundle Help\" \"LaTeX\"\n\"$TM_SUPPORT_PATH/lib/markdown_to_help.rb\" \"$TM_BUNDLE_SUPPORT/help.markdown\"\nhtml_footer\n",
  dontFollowNewOutput: true,
  input: "none",
  name: "Help",
  output: "showAsHTML",
  scope: "text.tex.latex",
  uuid: "37B43A9E-AD5E-11D9-97B0-000D93B6E43C"},
 {beforeRunningCommand: "nop",
  command: "toggle_style.rb -style=emph",
  fallbackInput: "word",
  input: "selection",
  keyEquivalent: "@i",
  name: "Italic",
  output: "insertAsSnippet",
  scope: "text.tex.latex",
  uuid: "4F91DE78-EA89-48A0-98E4-7A1CB64C7D87"},
 {beforeRunningCommand: "nop",
  command: "texMate.py sync 1",
  input: "none",
  keyEquivalent: "^~@o",
  name: "Jump to Current Line in Viewer",
  output: "discard",
  scope: "text.tex.latex",
  uuid: "D8B2D295-AD3C-11D9-BD97-000D93B6E43C"},
 {beforeRunningCommand: "nop",
  command: 
   "#!/usr/bin/env ruby\nrequire \"\#{ENV['TM_SUPPORT_PATH']}/lib/exit_codes\"\nrequire \"\#{ENV['TM_BUNDLE_SUPPORT']}/lib/config_helper.rb\"\n@plist = Config.load\nshortcutHash = @plist['symbols']\ncurrentWord = STDIN.read\nif (shortcutHash.has_key?(currentWord)) then\n  print shortcutHash[currentWord]\nelse\n  TextMate.exit_discard\nend",
  fallbackInput: "word",
  input: "selection",
  keyEquivalent: "@\\",
  name: "LaTeX Symbol Based on Current Word / Selection",
  output: "replaceSelectedText",
  scope: "text.tex.latex, text.bibtex",
  uuid: "A7D549C1-055E-4181-84F2-BA713EB66341"},
 {beforeRunningCommand: "nop",
  command: 
   "#!/usr/bin/ruby\n# This command is meant to be used for quick insertion of your LaTeX template files. They should be placed\n# in the directory ~/Library/Application Support/LaTeX/Templates. A pop-up is provided, letting you pick\n# the template file you want inserted, and then it gets inserted as a snippet. See\n# http://macromates.com/textmate/manual/snippets#snippets for what this implies.\nrequire ENV['TM_SUPPORT_PATH'] + '/lib/osx/plist'\nrequire ENV['TM_SUPPORT_PATH'] + '/lib/exit_codes.rb'\nrequire ENV['TM_SUPPORT_PATH'] + '/lib/ui.rb'\nrequire ENV['TM_SUPPORT_PATH'] + '/lib/escape.rb'\npath = ENV['HOME'] + '/Library/Application Support/LaTeX/Templates/'\n[{\"a\" => \"2\", \"b\" => \"5\"}, {\"a\" => \"1\", \"b\" => \"4\"}].to_plist\nunless FileTest.directory?(path) then\n  TextMate.exit_show_tool_tip \"You need to create the directory \#{path} first and\\n populate it with your favorite LaTeX template files before using this command.\"\nelse\n  files = `ls \"\#{path}\"`.split(\"\\n\")\n  TextMate.exit_show_tool_tip \"You need to populate the template directory with some template files!\" if files.empty?\n  entries = files.map do |file|\n    content = File.read(path + file)\n    { \"filename\" => file, \"content\" => content}\n  end\nparams = { \"entries\" => entries }\n  dialog = ENV['DIALOG']\n  return_plist = `\"\#{dialog}\" -cmp \#{e_sh params.to_plist} \#{e_sh(ENV['TM_BUNDLE_SUPPORT'] + '/nibs/LaTeXTemplate.nib')}`\n  return_hash = OSX::PropertyList::load(return_plist)['result']\n\tTextMate.exit_discard if return_hash.nil?\n\ttext = return_hash['returnArgument'][0].scan(/\\n|.+\\n?/)\n  first_line = text[0]\n# The user can force the template to be interpreted as a snippet, by\n# adding this line: #!TEX style=snippet\n  if first_line.match(/^%!TEX\\s+style\\s*=\\s*snippet\\s*/) then\n    TextMate.exit_insert_snippet(text[1..-1])\n  else\n    print(text.join(\"\"))\n  end\nend\n",
  input: "none",
  name: "LaTeX Template",
  output: "afterSelectedText",
  scope: "text.tex.latex",
  tabTrigger: "temp",
  uuid: "0E901597-FFB6-4D81-A57D-821A9B5089A5"},
 {beforeRunningCommand: "nop",
  captureFormatString: "$3",
  capturePattern: "^([^:]*):([^:]*):(.*)$",
  command: 
   "#!/usr/bin/env ruby\nrequire ENV[\"TM_SUPPORT_PATH\"] + \"/lib/exit_codes.rb\"\nrequire ENV[\"TM_SUPPORT_PATH\"] + \"/lib/ui.rb\"\nrequire ENV[\"TM_BUNDLE_SUPPORT\"] + \"/lib/LaTeXUtils.rb\"\nphrase = STDIN.read.chomp\ninclude LaTeX\nbegin\n  items = LaTeX.get_labels\n  items = items.grep(/\#{phrase}/) if phrase != \"\"\n  TextMate.exit_discard if items.empty?\n  if items.length > 1 then\n    choice = TextMate::UI.menu(items)\n    TextMate.exit_discard if choice.nil?\n    choice = items[choice]\n  else\n    choice = items[0]\n  end\n  selection = choice.slice(/^[^%]+/).strip\n  if ENV['TM_SCOPE'].match(/label/) then\n    print selection\n  elsif selection.match(/^eq(n)?:/)\n    TextMate.exit_insert_snippet \"\\\\\\\\${1:eqref}\\{\#{selection}\\}\"\n  else\n    TextMate.exit_insert_snippet(\"\\\\\\\\${1:ref}\\{\#{selection}\\}\")\n  end\nrescue RuntimeError => e\n  TextMate.exit_show_tool_tip(e.message)\nend\n",
  fallbackInput: "word",
  fileCaptureRegister: "1",
  input: "selection",
  keyEquivalent: "~",
  lineCaptureRegister: "2",
  name: "Label Based on Current Word / Selection…",
  output: "replaceSelectedText",
  scope: "text.tex.latex, meta.reference.label.latex",
  uuid: "9A3FE182-40AB-4980-AB6C-32DDA22DE41D"},
 {beforeRunningCommand: "nop",
  command: 
   "#!/usr/bin/env ruby\n#\n# Produces the right enumeration command for each environment.\n# For instance in a itemize environment, will produce \\item\n# while in a questions environment will produce \\question\n#\nlinesbefore = ENV['TM_LINE_NUMBER'].to_i-1\ncolumns = ENV['TM_COLUMN_NUMBER'].to_i-1\ntextArray = STDIN.readlines\nmyStr = textArray[0..linesbefore-1].join\nmyStr << textArray[linesbefore].slice(0..columns-1)\ntheArray = Array.new\ntheRegexp = Regexp.new('(\\\\\\begin\\{|\\\\\\end\\{)(\\w+[*]?)(\\})')\ntoInsertNoBeamer = { \"itemize\" => \"\\\\item $1\", \"enumerate\" => \"\\\\item $1\", \"description\" => \"\\\\item[${1:label}] ${2:description}\", \"parts\" => \"\\\\part $1\", \"questions\" => \"\\\\question $1\" }\ntoInsertBeamer = { \"itemize\" => \"\\\\item<${1:+-}> $2\", \"enumerate\" => \"\\\\item<${1:+-}> $2\", \"description\" => \"\\\\item<+->[${1:label}] ${2:description}\", \"overprint\" => \"\\\\onslide<${1:+}>\\n\\t$2\", \"overlayarea\" => \"\\\\only<${1:+}> $2\" }\ntoInsert = /beamer/.match(ENV['TM_SCOPE'].to_s) ? toInsertBeamer : toInsertNoBeamer\nresults = myStr.scan(theRegexp)\nif (results)\n  results.each{|e|\n    if (e[0] == \"\\\\begin\\{\")\n      theArray << e[1]\n    elsif (e[0] == \"\\\\end\\{\")\n      if (theArray.last == e[1])\n        theArray.pop\n      else\n        puts(\"Badly nested begin-end blocks\")\n        exit 1\n      end\n    else\n      puts(\"Problem:\",e[0])\n      exit 1\n    end\n  }\n  envName = theArray.pop\n  str_to_add = \"\\n\"\n  if (/\\\\begin\\{/.match(textArray[linesbefore]))\n    str_to_add << \"\\t\"\n  end\n  if (toInsert.has_key?(envName))\n    str_to_add << toInsert[envName]\n  elsif [\"cases\",\"align\",\"aligned\",\"gather\",\"gathered\",\"split\"].include?(envName)\n    str_to_add = \"\\\\\\\\\\\\\\\\\" + str_to_add\n  else\n    str_to_add << \"\\\\item \"\n  end\n  print str_to_add\nelse\n  print(\"\\n\")\nend",
  input: "document",
  keyEquivalent: "",
  name: "New Item",
  output: "insertAsSnippet",
  scope: "text.tex.latex meta.function.environment",
  uuid: "948DDCF2-0EB5-46A3-B970-09597D268BAF"},
 {beforeRunningCommand: "nop",
  command: 
   "${TM_RUBY:-ruby} <<\"RUBY\"\nrequire \"\#{ENV['TM_SUPPORT_PATH']}/lib/escape.rb\"\nrequire \"\#{ENV['TM_BUNDLE_SUPPORT']}/lib/LaTeXUtils.rb\"\n\nmaster = LaTeX.master(ENV['TM_LATEX_MASTER'] || ENV['TM_FILEPATH'])\n\nDir.chdir(File.dirname(master)) unless master.nil?\n\ninput = ENV['TM_SELECTED_TEXT'] || ENV['TM_CURRENT_LINE']\noptions = input.scan(/\\\\(?:include|input|includegraphics|lstinputlisting)(?:%.*\\n[ \\t]*)?(?>\\[.*?\\])?(?:%.*\\n[ \\t]*)?(?>\\{(.*?)\\})/m)\nif options.empty?\n\tprint \"Did not find any appropriate item to open in \#{ENV['TM_SELECTED_TEXT'] ? \"selection\" : \"current line\" }\"\nelse\n  options[0].each{|el| el.gsub!(/(^\\\")?(\\\"$)?/, '')} \n  filepath = `kpsewhich \#{e_sh options[0]}`.chomp\n  if filepath.empty?\n    print \"Could not locate file for path `\#{options[0]}'\"\n  else\n    `open \#{e_sh filepath}`\n  end\nend\nRUBY\n",
  fallbackInput: "line",
  input: "selection",
  keyEquivalent: "",
  name: "Open Included Item",
  output: "showAsTooltip",
  scope: "text.tex.latex meta.include",
  uuid: "B3E6DCF7-6323-4229-94D7-59996BDF07EC"},
 {beforeRunningCommand: "nop",
  command: 
   "${TM_RUBY:-ruby} <<\"RUBY\"\nrequire \"\#{ENV['TM_SUPPORT_PATH']}/lib/escape.rb\"\nrequire \"\#{ENV['TM_BUNDLE_SUPPORT']}/lib/LaTeXUtils.rb\"\n\nmaster = LaTeX.master(ENV['TM_LATEX_MASTER'] || ENV['TM_FILEPATH'])\n\nif master\n  `open -a TextMate \#{e_sh master}`\nelse\n  echo 'No master file was defined.'\nend\nRUBY\n",
  fallbackInput: "line",
  input: "selection",
  keyEquivalent: "^@l",
  name: "Open Master File",
  output: "showAsTooltip",
  scope: "text.tex.latex",
  uuid: "BC36A3C7-F9B2-47D4-83FB-2BEB93F14889"},
 {beforeRunningCommand: "nop",
  command: 
   "# just to remind you of some useful environment variables\n# see Help / Environment Variables for the full list\nconfigure.py",
  input: "none",
  keyEquivalent: "~@,",
  name: "Preferences…",
  output: "showAsTooltip",
  scope: "text.tex.latex",
  uuid: "8F41368E-4E01-41A9-8FCF-19D4A4032AE2"},
 {beforeRunningCommand: "nop",
  command: 
   "#!/usr/bin/env ruby\nrequire 'pp'\nlines = STDIN.read\ns = lines.slice!(/^.*?\\}\\s*\\n/)\n# Place any \\hline's not on a line of their own in their own line\nlines.gsub!(/(\\\\hline\\s*)(?!\\n)/,\"\\\\hline\\\\\\\\\\\\\\\\\")\nlines = lines.split(/\\\\\\\\/)\ndata = lines.map do |line|\n  line.split(/&/).map{|i| i.strip}\nend\ncols = data.map{|i| i.length}.max\nwidths = []\ncols.times do |i|\n  widths << data.inject(0) do |maximum,line| if line.length <= i then maximum else [maximum,line[i].length].max end end\nend\npattern = widths.map{|i| \"%\#{i}s\"}.join(\" & \")\nprint s.chomp\nprev=false\nfor line in data do\n  print(prev ? \"\\\\\\\\\\n\" : \"\\n\")\n  if line.length <= 1 then\n    print line\n    prev=false\n  else\n    line.fill(\"\",(line.length+1)..cols)\n    printf(pattern,*line)\n    prev=true\n  end\nend\nprint \"\\n\"\n",
  fallbackInput: "scope",
  input: "selection",
  keyEquivalent: "^&",
  name: "Reformat",
  output: "replaceSelectedText",
  scope: "text.tex.latex meta.data.environment.tabular.latex",
  uuid: "FB412036-2D62-41A3-BDFA-F897933132AA"},
 {beforeRunningCommand: "nop",
  command: 
   "#!/usr/bin/env ruby\nrequire 'pp'\nrequire ENV[\"TM_SUPPORT_PATH\"] + \"/lib/escape.rb\"\ndata=STDIN.readlines\nl,c = ENV['TM_LINE_NUMBER'].to_i-ENV['TM_INPUT_START_LINE'].to_i, ENV['TM_LINE_INDEX'].to_i\ncol_no = data[l].slice(/^.{\#{c}}/).scan(\"&\").length\nif col_no == 0 then\n  data.each do |line|\n    if line =~ /^[^&]*&(.*)/ then\n      print $1\n    else\n      print line\n    end\n  end\nelse\n  data.each do |line|\n    if line =~ /^([^&]*&){\#{col_no}}(?:[^&]*&)(.*\\n?)/ then\n      print $1 + $2\n    else\n      print line\n    end\n  end\nend",
  fallbackInput: "scope",
  input: "selection",
  keyEquivalent: "^~",
  name: "Remove Column",
  output: "replaceSelectedText",
  scope: "text.tex.latex  meta.data.environment.tabular.latex",
  uuid: "6E70284B-1694-46F5-BA99-FC3CC22705C6"},
 {beforeRunningCommand: "nop",
  command: 
   "# just to remind you of some useful environment variables\n# see Help / Shell Variables for the full list\n. \"${TM_SUPPORT_PATH}/lib/html.sh\"\n. \"${TM_SUPPORT_PATH}/lib/webpreview.sh\"\n\n# Prepare output window.\nhtml_header 'Run BibTeX'\n\ntexMate.py bibtex 1",
  input: "none",
  name: "Run BibTeX",
  output: "showAsHTML",
  scope: "text.tex.latex",
  uuid: "4C05FB6C-AA32-4217-8788-D840D49E82CD"},
 {beforeRunningCommand: "nop",
  command: 
   "# just to remind you of some useful environment variables\n# see Help / Shell Variables for the full list\n. \"${TM_SUPPORT_PATH}/lib/html.sh\"\n. \"${TM_SUPPORT_PATH}/lib/webpreview.sh\"\n\n# Prepare output window.\nhtml_header 'Run MakeIndex'\n\ntexMate.py index 1\n",
  input: "none",
  name: "Run Makeindex",
  output: "showAsHTML",
  scope: "text.tex.latex",
  uuid: "0A27EDBA-2C7C-44CF-B2B0-1B3B7BF8D7D6"},
 {beforeRunningCommand: "nop",
  command: 
   "#!/usr/bin/env ruby\nrequire ENV['TM_SUPPORT_PATH'] + '/lib/textmate.rb';\nrequire ENV['TM_SUPPORT_PATH'] + '/lib/ui.rb';\n\nmodule TextMate\n  module UI\n    class << self\n\n      def request_file2(options = Hash.new,&block)\n\t   options[\"string-output\"] = \"\"\n        options['button1'] ||= \"OK\"\n        options['button2'] ||= \"Cancel\"\n        options[\"title\"] = options[:title] || \"Select File\"\n        options[\"informative-text\"] = options[:prompt] || \"\"\n        options[\"text\"] = options[:default] || \"\"\n        return cocoa_dialog(\"fileselect\", options,&block)\n      end\n\n    end\n  end\nend\n\nstartDir = ENV['TM_DIRECTORY'];\n\ndoc = STDIN.read();\nmaster = TextMate::UI.request_file2(\"with-directory\" => startDir, \"with-extensions\" => \".tex\");\n\nif master != nil then\n    puts '%!TEX root = ' + master[0]\nend\nputs doc",
  input: "document",
  name: "Set Master File",
  output: "replaceDocument",
  scope: "text.tex.latex",
  uuid: "B5E78339-A4E5-4D61-9E4A-B7D725ABA10A"},
 {beforeRunningCommand: "nop",
  command: 
   "#!/usr/bin/env ruby\nrequire ENV['TM_SUPPORT_PATH'] + '/lib/textmate.rb'\nrequire ENV['TM_SUPPORT_PATH'] + '/lib/ui.rb'\n\ndoc = STDIN.read();\nengine = TextMate::UI.request_string :prompt => \"Enter the typesetting command you want to use \\n(without parameters)\"\n\nif engine != nil then\n   puts '%!TEX TS-program = ' + engine\nend\nputs doc",
  input: "document",
  name: "Set Typesetting Engine",
  output: "replaceDocument",
  scope: "text.tex.latex",
  uuid: "87D82153-769C-45B9-A33C-F29C9121B67E"},
 {beforeRunningCommand: "nop",
  command: 
   "#!/usr/bin/env ruby\nrequire ENV['TM_SUPPORT_PATH'] + '/lib/textmate.rb'\nrequire ENV['TM_SUPPORT_PATH'] + '/lib/ui.rb'\n\ndoc = STDIN.read();\n\nparms = TextMate::UI.request_string :prompt => \"Enter the parameters for the typesetting engine\"\n\nif parms != nil then\n    puts '%!TEX TS-options = ' + parms\nend\nputs doc",
  input: "document",
  name: "Set Typesetting Parameters",
  output: "replaceDocument",
  scope: "text.tex.latex",
  uuid: "85A5D4B0-1657-40E8-881A-8DA0381D2977"},
 {beforeRunningCommand: "nop",
  captureFormatString: "$3",
  capturePattern: "^([^:]*):([^:]*):(.*)$",
  command: 
   "#!/usr/bin/env ruby\nrequire ENV[\"TM_SUPPORT_PATH\"] + \"/lib/exit_codes.rb\"\nrequire ENV[\"TM_SUPPORT_PATH\"] + \"/lib/ui.rb\"\nrequire ENV[\"TM_BUNDLE_SUPPORT\"] + \"/lib/LaTeXUtils.rb\"\nphrase = STDIN.read.chomp\nTextMate.exit_show_tool_tip(\"No current ref found\") if phrase == \"\"\ninclude LaTeX\nbegin\n  items = FileScanner.label_scan(ENV[\"TM_LATEX_MASTER\"] || ENV[\"TM_FILEPATH\"]).find_all{|i| i.label.match(/\#{phrase}/)}\n  print items[0].context(10, true)\nrescue Exception => e\n  TextMate.exit_insert_text(e.message)\nend\n",
  fallbackInput: "word",
  fileCaptureRegister: "1",
  input: "selection",
  keyEquivalent: "^@l",
  lineCaptureRegister: "2",
  name: "Show Label as Tool Tip",
  output: "showAsTooltip",
  scope: "meta.reference.label.latex",
  uuid: "EA8D1116-805A-4583-A028-F5328DDE4B75"},
 {beforeRunningCommand: "nop",
  command: 
   "#!/usr/bin/env ruby\nrequire ENV['TM_SUPPORT_PATH'] + '/lib/exit_codes.rb'\nrequire ENV['TM_SUPPORT_PATH'] + '/lib/escape.rb'\nrequire ENV['TM_SUPPORT_PATH'] + '/lib/web_preview.rb'\nrequire \"\#{ENV['TM_BUNDLE_SUPPORT']}/lib/LaTeXUtils.rb\"\nhtml_header \"LaTeX Document Outline\", \"LaTeX\"\nREGEX = /\\\\(part|chapter|section|subsection|subsubsection|paragraph|subparagraph)\\*?(?:%.*\\n[ \\t]*)?(?:(?>\\[(.*?)\\])|\\{([^{}]*(?:\\{[^}]*\\}[^}]*?)*)\\})/\nINCLUDE_REGEX = /\\\\(?:input|include)(?:%.*\\n[ \\t]*)?(?>\\{(.*?)\\})/\nNON_COMMENT_REGEX = /^([^%]+$|(?:[^%]|\\\\%)*)(?=%|$)/\nclass String\n  def adjust_end(new_piece)\n    new_form = self.sub(/[^\\/]*$/,new_piece)\n    new_form += \".tex\" unless new_form.match(/\\.tex$/)\n    new_form\n  end\nend\nclass Section < String\n  def <=>(other_part)\n    parts = [\"root\",\"part\",\"chapter\",\"section\",\"subsection\",\"subsubsection\",\"paragraph\",\"subparagraph\"]\n    return parts.index(self) <=> parts.index(other_part)\n  end\n  def <(other_part)\n    (self<=>other_part) == -1\n  end\nend\ndef outline_points(filename)\n  points = []\n  if filename.is_a?(String) then\n    data = File.read(filename)\n    name = \"url=file://\" + e_url(filename) + \"&\"\n  else\n    data = filename.read\n    name = \"\"\n  end\n  data.split(\"\\n\").each_with_index do |line, i|\n    line.match(NON_COMMENT_REGEX)\n    line = $1 || \"\"\n    points << [name,i+1,$1,$2 || $3] if line.match(REGEX)\n    points += outline_points(filename.adjust_end($1)) if line.match(INCLUDE_REGEX)\n  end\n  points\nend\nfile = LaTeX.master(ENV['TM_LATEX_MASTER'] || ENV['TM_FILEPATH'])\nif file.nil?\n  file = STDIN\nelse\n  file = File.expand_path(file, File.dirname(ENV['TM_FILEPATH']))\nend\nrequire 'pp'\npoints = outline_points(file)\n# sec = Section.new(\"section\")\ncurrent = [Section.new(\"root\")]\nstring = []\npoints.each do |file,line,part,title|\n  # pp [part,sec <=> part]\n  case current.last <=> part\n  when 1\n(current.pop; string << \"\\t\" * current.length + \"</ol>\") while current.last > part\n  when -1\n    string << \"\\t\" * current.length + \"<ol>\"\n    current << Section.new(part)\n  end\n  string << \"\\t\" * current.length + \"<li><a href=\\\"txmt://open?\#{file}line=\#{line}\\\">\#{title}</a></li>\"\nend\n(current.pop; string << \"\\t\" * current.length + \"</ol>\") while current.last != \"root\"\nputs string.join(\"\\n\")\nhtml_footer",
  fallbackInput: "word",
  input: "document",
  keyEquivalent: "@O",
  name: "Show Outline",
  output: "showAsHTML",
  scope: "text.tex.latex",
  uuid: "5AED5DFA-F084-4F12-8A06-D51C78E91D05"},
 {beforeRunningCommand: "nop",
  command: "toggle_style.rb -style=textsc",
  fallbackInput: "word",
  input: "selection",
  keyEquivalent: "@K",
  name: "Small Caps",
  output: "insertAsSnippet",
  scope: "text.tex.latex",
  uuid: "9B3C2535-5CB7-43B8-9A8E-BCAB1085A245"},
 {beforeRunningCommand: "nop",
  command: "LaTeXTidy.pl",
  input: "document",
  keyEquivalent: "^H",
  name: "Tidy",
  output: "replaceDocument",
  scope: "text.tex.latex",
  uuid: "DF9F9DF7-5F85-11D9-97D0-000D9332809C"},
 {beforeRunningCommand: "nop",
  command: 
   "#!/usr/bin/env ruby\nrequire ENV['TM_SUPPORT_PATH'] + \"/lib/escape.rb\"\ndata = STDIN.read\nlocation = [[ENV['TM_LINE_NUMBER'].to_i,ENV['TM_LINE_INDEX'].to_i]]\n# location = [[8,10],[6,10],[5,4]]\nclass String\n  def split_after_row(row)\n    lines = self.scan(/.*\\n?/)\n    before = lines[0..row-1].join(\"\")\n    after = lines[row..-1].join(\"\")\n    return [before,after]\n  end\n  def fix_back\n    stack = []\n    before_lines = self.scan(/.*\\n?/)\n    processed = []\n    until before_lines.empty?\n      line = before_lines.pop\n      case line\n      when /^(.*\\\\begin\\{)([^\\}\\*]*)(\\*?)(\\}.*\\n?)$/\n        if stack.empty? then\n          replace = $1 + $2 + ($3==\"\" ? \"*\" : \"\") + $4\n          return [:begin, before_lines.join(\"\") + replace + processed.reverse.join(\"\")]\n        else\n          stack.pop\n          processed << line\n        end\n      when /^(.*\\\\end\\{)([^\\}\\*]*)(\\*?)(\\}.*\\n?)$/\n        stack.push \"\"\n        processed << line\n      when /^(.*\\\\(?:chapter|part|(?:sub){0,2}section|(?:sub)?paragraph))(\\*?)(\\{.*\\n?)$/\n        replace = $1 + ($2==\"\" ? \"*\" : \"\") + $3\n        return [:section, before_lines.join(\"\") + replace + processed.reverse.join(\"\")]\n      else\n        processed << line\n      end\n    end\n    raise \"Unexpected!\"\n  end\n  def fix_forward\n    stack = []\n    after_lines = self.scan(/.*\\n?/)\n    processed = []\n    until after_lines.empty?\n      line = after_lines.shift\n      case line\n      when /^(.*\\\\begin\\{)([^\\}\\*]*)(\\*?)(\\}.*\\n?)$/\n        stack.push \"\"\n        processed << line\n      when /^(.*\\\\end\\{)([^\\}\\*]*)(\\*?)(\\}.*\\n?)$/\n        if stack.empty? then\n          replace = $1 + $2 + ($3==\"\" ? \"*\" : \"\") + $4\n          return [:end, processed.join(\"\") + replace + after_lines.join(\"\")]\n        else\n          stack.pop\n          processed << line\n        end\n      else\n        processed << line\n      end\n    end\n    raise \"Unexpected!\"\n  end\nend\n\nlocation.each do |row,col|\n  before, after = data.split_after_row(row)\n  status, before = before.fix_back\n  unless status == :section then\n    status, after = after.fix_forward\n  end\n  if col == 0 then\n    before_lines = before.scan(/.*\\n?/)\n    before_lines.pop\n    after = before_lines.pop + after\n    before = before_lines.join(\"\")\n  else\n    before_lines = before.scan(/.*\\n?/)\n\tbefore_lines.pop\n    line = before_lines.pop\n    before = before_lines.push(line[0..col-1]).join(\"\")\n   after = line[col..-1] + after\n  end\n  print e_sn(before) + \"\\$0\" + e_sn(after)\nend\n",
  fallbackInput: "document",
  input: "selection",
  keyEquivalent: "^*",
  name: "Toggle Starred",
  output: "insertAsSnippet",
  scope: "text.tex.latex",
  uuid: "37C520F9-A379-4BBC-AF62-22F7C0B63955"},
 {beforeRunningCommand: "nop",
  command: 
   ". \"${TM_SUPPORT_PATH}/lib/html.sh\"\n. \"${TM_SUPPORT_PATH}/lib/webpreview.sh\"\n\n# Prepare output window.\nhtml_header 'Clean Auxiliary files'\n\ntexMate.py clean 1",
  input: "none",
  keyEquivalent: "^~\x7F",
  name: "Trash aux Files",
  output: "showAsHTML",
  scope: "text.tex.latex",
  uuid: "F330276E-C4B2-11D9-B15D-000D93B6E43C"},
 {beforeRunningCommand: "saveActiveFile",
  bundleUUID: "46788DCE-6227-11D9-BFB1-000D93589AF6",
  command: 
   "#!/usr/bin/env ruby\n# coding: utf-8\n\nrequire ENV[\"TM_SUPPORT_PATH\"] + \"/lib/tm/process\"\nrequire ENV[\"TM_SUPPORT_PATH\"] + \"/lib/tm/htmloutput\"\nrequire ENV[\"TM_SUPPORT_PATH\"] + \"/lib/tm/save_current_document\"\nrequire ENV[\"TM_SUPPORT_PATH\"] + \"/lib/tm/require_cmd\"\n\n# To enable the typesetting of unsaved documents, you must change the “Save” setting of\n# this command to “Current File” and add the variable TM_LATEX_AUTOSAVE to TextMate's\n# Shell Variables preferences. Be warned that your document must be encoded as UTF-8 if\n# you excercise this option — becauseTextMate.save_current_document cannot know the file\n# encoding you prefer.\n\nTextMate.save_current_document unless ENV[\"TM_LATEX_AUTOSAVE\"].nil?\n\nTextMate.require_cmd(\"kpsewhich\")\n\ntexMate = ENV[\"TM_BUNDLE_SUPPORT\"] + \"/bin/texMate.py\"\nengine_version = TextMate::Process.run(texMate, \"version\")\nTextMate::HTMLOutput.show(:title => \"Typesetting “\#{ENV[\"TM_DISPLAYNAME\"] || File.basename(ENV[\"TM_FILEPATH\"])}”…\", :sub_title => engine_version) do |io|\n  TextMate::Process.run(texMate, 'latex', '1', :interactive_input => false) do |line|\n\tio << line\n  end\nend\n::Process.exit($?.exitstatus)\n",
  dontFollowNewOutput: false,
  input: "document",
  keyEquivalent: "@r",
  name: "Typeset & View (PDF)",
  output: "showAsHTML",
  scope: "text.tex",
  uuid: "6177C3DA-C580-11D9-B649-000393D4B5C8"},
 {beforeRunningCommand: "nop",
  command: "toggle_style.rb -style=texttt",
  fallbackInput: "word",
  input: "selection",
  keyEquivalent: "@k",
  name: "Typewriter",
  output: "insertAsSnippet",
  scope: "text.tex.latex",
  uuid: "17A74DB2-7B65-4083-A091-AD51023DA8D7"},
 {beforeRunningCommand: "nop",
  command: "toggle_style.rb -style=underline",
  fallbackInput: "word",
  input: "selection",
  keyEquivalent: "@u",
  name: "Underline",
  output: "insertAsSnippet",
  scope: "text.tex.latex",
  uuid: "4473F4D4-A7A1-4EA5-B418-0A194A7A3DE1"},
 {beforeRunningCommand: "nop",
  command: "toggle_style.rb -style=verb",
  fallbackInput: "word",
  input: "selection",
  keyEquivalent: "~@k",
  name: "Verb",
  output: "insertAsSnippet",
  scope: "text.tex.latex",
  uuid: "6B5C138A-1951-4AD2-BE95-52E498661029"},
 {beforeRunningCommand: "saveActiveFile",
  bundleUUID: "46788DCE-6227-11D9-BFB1-000D93589AF6",
  command: 
   "#  See the end of $watch_script (defined below) for changelog and version information.\n\nwatch_script=\"$TM_BUNDLE_SUPPORT\"/bin/latex_watch.pl\n\nfile=\"${TM_LATEX_MASTER:-$TM_FILEPATH}\"\ndirname=\"$(dirname \"$file\")\"\nbasename=\"$(basename \"$file\" .tex)\"\n\n# Check whether file is already being watched\npid_file=\"$dirname/.$basename.watcher_pid\"\nif [ -f \"$pid_file\" ]; then\n\tif [ 2 -eq $(/bin/ps -p $(cat \"$pid_file\") | /usr/bin/wc -l) ]\n\tthen\n\t\tok=$(CocoaDialog ok-msgbox \\\n\t\t\t--title \"LaTeX Watch: File already watched\" \\\n\t\t\t--text \"Stop watching?\" \\\n\t\t\t--informative-text \"The file '$file' is already being watched. Shall I stop watching it?\")\n\t\tif [ \"$ok\" -eq 1 ]; then\n\t\t\tkill $(cat \"$pid_file\")\n\t\tfi\n\t\texit\n\tfi\nfi\n\n# Make sure we can find the watch script...\nif [ \\! -f \"$watch_script\" ]; then\n\tCocoaDialog msgbox \\\n\t\t--button1 Cancel \\\n\t\t--title \"LaTeX Watch error\" \\\n\t\t--text \"Could not find script\" \\\n\t\t--informative-text \"The file '$watch_script' could not be found. Make sure you have installed it in the right place.\"\n\texit 1\nfi\n\n# ... and the Perl interpreter\nif [ -x \"/usr/bin/perl\" ]; then\n\t# We prefer /usr/bin/perl, because we want to use Foundation.pm\n\tperl=\"/usr/bin/perl\"\nelse\n\ttype perl || {\n\t\tCocoaDialog msgbox \\\n\t\t\t--button1 Cancel \\\n\t\t\t--title \"LaTeX Watch error\" \\\n\t\t\t--text \"Could not find Perl\" \\\n\t\t\t--informative-text \"I could not locate the perl executable! Make sure it's in your PATH ($PATH).\"\n\t\texit 1\n\t}\n\tperl=perl\nfi\n\n# Spawn progress bar. Ironically it's quite a CPU hog, so give it a low\n#  scheduling priority.\nnice -n 20 CocoaDialog progressbar --indeterminate --title 'LaTeX Watch' --text 'LaTeX Watch: Compiling document' </dev/console &>/dev/null &\nprogressbar_pid=$(jobs -p %%)\ndisown %%\n\nwatch_script_opts=\"--textmate-pid $PPID --progressbar-pid $progressbar_pid\"\nif [ -n \"$TM_LATEX_WATCH_DEBUG\" ]; then\n\twatch_script_opts=\"$watch_script_opts --debug\"\nfi\n\n\"$perl\" \"$watch_script\" $watch_script_opts \"$file\" &>/dev/console &\njobs -p %% > \"$pid_file\"\n",
  input: "none",
  keyEquivalent: "^@w",
  name: "Watch document",
  output: "discard",
  scope: "text.tex.latex",
  uuid: "4BB11B68-A0F5-4670-A0B9-B3982D10A54B"}]
