# Encoding: UTF-8

[{beforeRunningCommand: "saveActiveFile",
  command: 
   "#\n#\tCompile a single file to a.out and execute the code in the frontmost Terminal\n#\n\n# Get some HTML niceties\n. \"${TM_SUPPORT_PATH}/lib/html.sh\"\n. \"${TM_SUPPORT_PATH}/lib/webpreview.sh\"\n\n# Check existence of fortran compiler\n# set TM_FORTRAN to gfortran if it is not already set\n: ${TM_FORTRAN:=gfortran}\n# require the existence of the command and show HTML error message if the command is not found\nrequire_cmd \"$TM_FORTRAN\" \"You must set the <tt>TM_FORTRAN</tt> variable to the full path of your Fortran compiler (e.g. <tt>/usr/local/bin/gfortran</tt>). You may also set <tt>TM_FFLAGS</tt> for any Fortran compiler options.\"\n\n# Prepare output HTML in case the compilation fails\nhtml_header \"`basename $TM_FORTRAN` compile\"\n\n# TIP (from Allan Odgaard)\n#\tcommand1 &> >(command2)\n# pipes the output of 'command1' to 'command2' but the status is still evaluated from 'command1'. Really cool.\n\n# Pipe the output of the compiler to 'pre' which formats it nicely for HTML output\nif cd \"$TM_DIRECTORY\" && \"$TM_FORTRAN\" $TM_FFLAGS `basename \"$TM_FILEPATH\"` &> >(pre); then\n\t\n\t# if compilation went well, execute the code in the frontmost Terminal\n\t# TIP (from jacobolus): using -SOMETHING as entry point allows the end SOMETHING to be indented with the rest of the code\n\t# TIP (from infinilight): use TM_TERMINAL to detect which terminal to run\n\tTM_TERMINAL=`echo $TM_TERMINAL | tr \"[:upper:]\" \"[:lower:]\"`\n\techo $TM_TERMINAL\n\t\n\tif [ \"$TM_TERMINAL\" == \"iterm\" ]; then\n\t\t# iTerm code - simple and not necessarily robust\n\t\tosascript <<-APPLESCRIPT\n\t\t\ttell application \"iTerm\"\n\t\t\t\tactivate\n\t\t\t\tif not (exists current terminal) then\n\t\t\t\t\tset myterm to (make new terminal)\n\t\t\t\t\ttell myterm\n\t\t\t\t\t\tlaunch session \"Default Session\"\n\t\t\t\t\tend tell\n\t\t\t\tend if\n\t\t\t\ttell current terminal\n\t\t\t\t\ttell current session\n\t\t\t\t\t\twrite text \"cd \" & \"$TM_DIRECTORY\"\n\t\t\t\t\t\twrite text \"./a.out\"\n\t\t\t\t\tend tell\n\t\t\t\tend tell\n\t\t\tend tell\n\t\t\ttell application \"TextMate\"\n\t\t\t\tactivate\n\t\t\tend tell\n\t\tAPPLESCRIPT\n\telse\n\t\t# Apple Terminal code - checks that a window exists and is not buzy\n\t\tosascript <<-APPLESCRIPT\n\t\t\ttell application \"Terminal\"\n\t\t\t\tactivate\n\t\t\t\tset windowCount to (count of the windows)\n\t\t\t\tif windowCount is greater than 0 then\n\t\t\t\t\trepeat with w from 1 to windowCount\n\t\t\t\t\t\tif window 1 is busy then\n\t\t\t\t\t\t\tset frontmost of window 1 to false\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tdo script \"cd \" & \"$TM_DIRECTORY\" in window 1\n\t\t\t\t\t\t\tdo script \"./a.out\" in window 1\n\t\t\t\t\t\t\tset frontmost of window 1 to true\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\tend if\n\t\t\t\t\tend repeat\n\t\t\t\tend if\n\t\t\t\ttell window 1\n\t\t\t\t\tdo script \"cd \" & \"$TM_DIRECTORY\" & \" && ./a.out\"\n\t\t\t\t\tset frontmost to true\n\t\t\t\tend tell\n\t\t\tend tell\n\t\t\ttell application \"TextMate\"\n\t\t\t\tactivate\n\t\t\tend tell\n\t\tAPPLESCRIPT\n\tfi\n\n\texit_discard\n\nelse\n\t# if compilation failed, show compiler's output in HTML preview\n\texit_show_html \"<h2>Compilation failed</h2>\"\n\nfi\n",
  input: "none",
  keyEquivalent: "@r",
  name: "Compile & Execute Single File",
  output: "discard",
  scope: "source.fortran",
  uuid: "EDD1628F-BB8C-4EC1-AFBD-90EC260F45B9"},
 {beforeRunningCommand: "saveActiveFile",
  command: 
   "#\n#\tCompile a single file to a.out\n#\n\n# Get some HTML niceties\n. \"${TM_SUPPORT_PATH}/lib/html.sh\"\n. \"${TM_SUPPORT_PATH}/lib/webpreview.sh\"\n\n# Check existence of fortran compiler\n# set TM_FORTRAN to gfortran if it is not already set\n: ${TM_FORTRAN:=gfortran}\n# require the existence of the command and show HTML error message if the command is not found\nrequire_cmd \"$TM_FORTRAN\" \"You must set the <tt>TM_FORTRAN</tt> variable to the full path of your Fortran compiler (e.g. <tt>/usr/local/bin/gfortran</tt>). You may also set <tt>TM_FFLAGS</tt> for any Fortran compiler options.\"\n\n# Prepare output window\nhtml_header \"`basename $TM_FORTRAN` compile\"\n\n# TIP: from Allan Odgaard\n# \tcommand1 &> >(command2)\n# pipes the output of 'command1' to 'command2' but the status is still evaluated from 'command1'. Really cool.\n\n# Pipe the output of the compiler to 'pre' which formats it nicely for HTML output\nif cd \"$TM_DIRECTORY\" && \"$TM_FORTRAN\" $TM_FFLAGS `basename \"$TM_FILEPATH\"` &> >(pre); then\n\techo \"</pre>\"\n\techo \"<h2>Successfully compiled a.out</h2>\"\nelse\n\techo \"</pre>\"\n\techo \"<h2>Compilation failed</h2>\"\nfi\n\nhtml_footer\n",
  input: "none",
  keyEquivalent: "@b",
  name: "Compile Single File",
  output: "showAsHTML",
  scope: "source.fortran",
  uuid: "21AF6BCC-5AD2-4B47-8A6B-0EB7F27BD97C"},
 {beforeRunningCommand: "nop",
  command: 
   ". \"$TM_SUPPORT_PATH/lib/webpreview.sh\"\n\nhtml_header \"Fortran Format Cheat Sheet\"\n\nMarkdown.pl \"$TM_BUNDLE_SUPPORT/format_syntax.md\"\n\nhtml_footer",
  input: "none",
  keyEquivalent: "^H",
  name: "Format Cheat Sheet",
  output: "showAsHTML",
  scope: "source.fortran",
  uuid: "46575B73-BDD7-4905-BFCB-2B1C9AA4673D"},
 {beforeRunningCommand: "nop",
  command: 
   "echo \"function $TM_CURRENT_WORD(\\$1)\"\necho \"\t\\$2, intent(\\${3:inout}) :: \\$1\"\necho \"\t\\$4 :: $TM_CURRENT_WORD\"\necho \"\t\\$0\"\necho \"end function $TM_CURRENT_WORD\"",
  fallbackInput: "word",
  input: "selection",
  keyEquivalent: "$\n",
  name: "Function based on current word",
  output: "insertAsSnippet",
  scope: "source.fortran",
  uuid: "0D6DE4E4-53AF-44E4-B8B8-D4F36FF96F77"},
 {beforeRunningCommand: "nop",
  command: 
   "line=$TM_CURRENT_LINE\nheader=$TM_SELECTED_TEXT\n\n# extract header from current line\nif [[ -z \"$header\" ]] && $(egrep -q <<<\"$line\" '#(import|include)'); then\n   header=$(sed -n <<<\"$line\" 's/[^<\"]*[<\"]\\([^\">]*\\).*/\\1/p')\nfi\n\n# ask user about header\nif [[ -z \"$header\" ]]; then\n   res=$(CocoaDialog inputbox --title \"Open Header Quickly\" --no-newline --informative-text \"Header name?\"  --text \"foobar\"  --button1 \"Open\" --button2 \"Cancel\")\n   [[ $(head -n1 <<<\"$res\") == \"2\" ]] && exit\n   header=$(tail -n1 <<<\"$res\")\nfi\n\n# If Spotlight is available, avail ourselves of it.\n# otherwise, use the old 'find'-based method.\n#\n# The Spotlight method has the advantage of being\n# both reasonably fast and catching all the corner\n# cases, many of which are missed by the old method.\n#\nif [[ `which mdfind` != *\"not found\" ]]; then\n\t# we have Spotlight\n\tfiles=`${TM_RUBY:-ruby} \"$TM_BUNDLE_SUPPORT/SpotlightSearch.rb\" \"$header\"`\nelse\n\t# old method\n\tarr=(\"/usr/include\"\n\t\"${TM_PROJECT_DIRECTORY:-$TM_DIRECTORY}\"\n\t)\n\n\tfiles=$(for dir in \"${arr[@]}\";\n\t\tdo find \"$dir\" -path \"*/$header\"; done|sort|uniq)\nfi\n\nif [[ -n \"$files\" ]];\n   then IFS=$'\\n'; mate $files &>/dev/null &\n   else echo \"No headers found.\"\nfi\n",
  input: "selection",
  keyEquivalent: "@D",
  name: "Quick Open",
  output: "showAsTooltip",
  scope: "source.fortran",
  uuid: "ED1485C9-393F-4B62-A8E8-62B242E4C7CF"},
 {beforeRunningCommand: "nop",
  command: 
   "echo \"subroutine $TM_CURRENT_WORD(\\$1)\"\necho \"\t\\$2, intent(\\${3:inout}) :: \\$1\"\necho \"\t\\$0\"\necho \"end subroutine $TM_CURRENT_WORD\"",
  fallbackInput: "word",
  input: "selection",
  keyEquivalent: "$\n",
  name: "Subroutine based on current word",
  output: "insertAsSnippet",
  scope: "source.fortran",
  uuid: "8806B464-11D1-419E-B883-3727F144FCC5"}]
