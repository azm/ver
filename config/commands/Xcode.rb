# Encoding: UTF-8

[{beforeRunningCommand: "nop",
  command: 
   "PROJECT=\"project=$(find_xcode_project.rb)\"\n\nif [[ -n \"$TM_SELECTED_FILES\" ]]; then\n  eval arr=(\"$TM_SELECTED_FILES\")\n  xcode_project.rb \"$PROJECT\" \"${arr[@]/#/add=}\"\nelif [[ -n \"$TM_FILEPATH\" ]]; then\n  xcode_project.rb \"$PROJECT\" add=\"$TM_FILEPATH\"\nelse\n  exit_show_tool_tip \"No files selected.\"\nfi\n",
  input: "none",
  keyEquivalent: "^X",
  name: "Add to Active Target",
  output: "showAsTooltip",
  uuid: "E435839A-880B-4E5F-9078-71BC595F2EA0"},
 {autoScrollOutput: true,
  beforeRunningCommand: "saveModifiedFiles",
  command: "\"${TM_BUNDLE_SUPPORT}/bin/run_xcodebuild.sh\"\n",
  input: "none",
  keyEquivalent: "@b",
  name: "Build",
  output: "showAsHTML",
  uuid: "9656317E-73EB-11D9-9848-000D93589AF6"},
 {autoScrollOutput: 1,
  beforeRunningCommand: "saveModifiedFiles",
  command: 
   "# this command calls xcodebuild giving the name of the project\n# directory as the project to build and parses the output for\n# file/line information then plays a succes/failure sample\n# based on the final outcome\n#\n# if the build succeeds, it will run the target\n\nXCODE_PROJECT_FILE=$(ruby -- \"${TM_BUNDLE_SUPPORT}/bin/find_xcode_project.rb\")\nexport XCODE_PROJECT_FILE\n\nexport XCODE_RUN_BUILD=1\n\"${TM_BUNDLE_SUPPORT}/bin/run_xcodebuild.sh\"\n\n#&& \"${TM_BUNDLE_SUPPORT}/bin/run_xcode_target.rb\" -project_dir=\"$XCODE_PROJECT_FILE\"\n",
  input: "none",
  keyEquivalent: "@r",
  name: "Build & Run",
  output: "showAsHTML",
  uuid: "B0254A99-7750-4A06-937A-9A453ECE3A6C"},
 {autoScrollOutput: 1,
  beforeRunningCommand: "saveModifiedFiles",
  command: 
   "XCODE_BUILD_VERB=\"clean\"\nexport XCODE_BUILD_VERB\n\"${TM_BUNDLE_SUPPORT}/bin/run_xcodebuild.sh\"\n",
  input: "none",
  name: "Clean",
  output: "showAsHTML",
  uuid: "392068ED-4C79-42D8-9DE8-53867928B3B0"},
 {beforeRunningCommand: "nop",
  bundleUUID: "D619CB94-53ED-41C5-963B-401492CE2602",
  command: 
   ". \"$TM_SUPPORT_PATH/lib/webpreview.sh\"\nhtml_header \"XCode Help\" \"XCode\"\n\nMarkdown.pl <<'EOF'\nThis bundle contains a set of useful commands for Xcode users.\n\nSeveral of the commands will use your Xcode project file and will try to find this by first checking the root folder of your project (`TM_PROJECT_DIRECTORY`) searching for a project with the extensions `xcodeproj`, `xcode`, or `pbproj`. If nothing is found, the folder of the currently open file (`TM_DIRECTORY`) will be checked, and then the parent and ancestor folders of this (until the project file is found).\n\nNormally it should work out-of-the-box when dragging the folder containing your Xcode project and sources to TextMate. But if you have an atypical setup, you may need to explicitly set the project file, see Settings below for details.\n\n## Commands\n\n*   __Build & Run__ (&#x2318;R)\n\n    First do a normal build. If that succeeds, run the target and display console output.\n\n*   __Build__ (&#x2318;B)\n\n    Build the project using [`xcodebuild`](http://developer.apple.com/documentation/Darwin/Reference/ManPages/man1/xcodebuild.1.html) with the active build configuration and show the result pretty-printed and with potential source references shown as clickable links.\n\n    A sample will be played based on the success/failure of the build. See Settings below for how to disable this.\n\n*   __Run__ (&#x21E7;&#x2318;R)\n\n    Scan the project file for a target of type _application_ or _tool_ and run it.\n    \n    For _application_ targets, TextMate will display the application’s output in the command’s HTML window.\n\n    For _tool_ targets, TextMate will use the Terminal application to run the tool.\n\n    The `DYLD_FRAMEWORK_PATH` and `DYLD_LIBRARY_PATH` environment variables are set to the targets folder before running the target.\n\n    If the project has multiple _tool_ and _application_ targets the command will display a dialog from which you can choose the target you wish to run. You can set `XC_TARGET_NAME` to always run a single target, see Settings below for how to configure this.\n\n*   __Run Tests__\n\n\tScan the project file for a unit test target and run it.\n\n*   __Clean__\n\n    This will clear the target (done by running `xcodebuild clean` with the project and active build configuration as arguments).\n\n*   __New Project Using Xcode Template…__\n\n\tCreates a new Xcode project from one of Xcode's templates.\n\n*   __Open Project in Xcode…__\n\n\tIf&mdash;using the same heuristics as the Run command&mdash;an Xcode project can be found, open it in Xcode.\n\n*   __Import Project…__\n\n    Asks you for an Xcode project, and will then create (and open) a TextMate project that mimics the groups and files present in that project.\n\n*   __Import Frontmost Project__\n\n    Create a TextMate project with groups and files like the frontmost project which is open in Xcode.\n    \n## Settings\n\n*   `TM_XCODE_PROJECT`\n\n    If your file structure is so that TextMate can't automatically find your Xcode project, then you can set this environment variable to the full path of the project file.\n    \n    It makes the most sense to set this as a project specific variable (as opposed to a global variable). This is done by deselecting everything in the project drawer and then clicking the small circled I button in the lower right corner of the drawer.\n\n*   `TM_MUTE`\n\n    If you do not like the samples being played after a build, you can set this variable to 1. This can be done in Preferences &#x2192; Advanced &#x2192; Shell Variables.\n\n*   `XC_TARGET_NAME`\n\n    If there are multiple targets in a project then you can set this environment variable to the name of the target you want to run to avoid the pop-up selector. This would normally be set as a project specific variable (see `TM_XCODE_PROJECT` above for how to do this).\n\n## Credits\n\nMajority of work done by Chris Thomas. Additional work by Allan Odgaard with support from Mark Rowe and Rob Rix.\n\nEOF\n\nhtml_footer",
  input: "none",
  name: "Help",
  output: "showAsHTML",
  uuid: "31F1A06C-0990-4BD7-8E63-D65E7BCD485D"},
 {beforeRunningCommand: "nop",
  command: 
   "# import the frontmost opened project window in Xcode\n\nsource_path=$(osascript -e 'tell application \"Xcode\" to get the path of project 1')\ndest_path=\"${source_path%.*}.tmproj\"\n\n# FIXME probably should move the old dest_path somewhere and only nuke it if the conversion is successful\n\n\"$TM_BUNDLE_SUPPORT/bin/xcode_to_tmproj\" \"$source_path/project.pbxproj\" \"$dest_path\" && open \"$dest_path\"\n\n",
  input: "none",
  keyEquivalent: "",
  name: "Import Frontmost Project",
  output: "showAsTooltip",
  uuid: "8104FD3A-DD58-45CA-8FC8-F64680261F13"},
 {beforeRunningCommand: "nop",
  command: 
   "#!/usr/bin/env ruby\n# import the frontmost opened project window in Xcode\n\nsource_path = %x{osascript -e 'tell application \"TextMate\"\n\tchoose file with prompt \"Please choose an Xcode project:\"\n\tget the POSIX path of the result\nend tell'}.chomp\n\ndest_path = source_path.chomp.sub(/\\.(xcodeproj|xcode|pbproj)\\/?$/, \".tmproj\")\n\n# FIXME probably should move the old dest_path somewhere and only nuke it if the conversion is successful\n\n%x{\"\#{ENV['TM_BUNDLE_SUPPORT']}/bin/xcode_to_tmproj\" \"\#{source_path}/project.pbxproj\" \"\#{dest_path}\" && open \"\#{dest_path}\"}",
  input: "none",
  name: "Import Project…",
  output: "openAsNewDocument",
  uuid: "775EC3D9-4799-4454-85E5-5112EFCC2A15"},
 {beforeRunningCommand: "nop",
  command: 
   "#!/usr/bin/env ruby -wKU\n\nrequire ENV['TM_SUPPORT_PATH'] + '/lib/textmate'\n\nproject_file = ENV['XCODE_PROJECT_FILE'] || %x{ruby -- \"${TM_BUNDLE_SUPPORT}/bin/find_xcode_project.rb\"}.strip\n\nLogFile = project_file + '/' + ENV['LOGNAME'] + '.tm_build_errors'\n\nabort \"No errors found\" unless File.exists?(LogFile)\n\nerrors = []\nFile.readlines(LogFile).map do |error|\n  file, line, error = error.split('|')\n  if existing_error = errors.find { |e| e[:file] == file and e[:line] == line }\n    existing_error[:error] << error\n  else\n    errors << {:file => file, :line => line, :error => error}\n  end\nend\n\nabort \"No errors found\" if errors.empty?\n\ncurrent_error = nil\n\nerrors.each_with_index do |error, index|\n  if error[:file] == ENV['TM_FILEPATH'] and error[:line] == ENV['TM_LINE_NUMBER']\n    current_error = index\n    break\n  end\nend\n\nif current_error\n  current_error += 1\n  current_error = 0 if current_error > errors.size - 1\nelse\n  current_error = 0\nend\n\nTextMate.go_to :file => errors[current_error][:file], :line => errors[current_error][:line]\nprint errors[current_error][:error]",
  input: "none",
  keyEquivalent: "@=",
  name: "Jump to Next Error",
  output: "showAsTooltip",
  uuid: "BA7499F1-F44C-43BC-9D81-AA1E889B35F7"},
 {beforeRunningCommand: "nop",
  command: 
   "PROJECT_FILE=$(ruby -- \"${TM_BUNDLE_SUPPORT}/bin/find_xcode_project.rb\")\n#PROJECT_FILE=${PROJECT_FILE##*/}\n\n\"${TM_BUNDLE_SUPPORT}/bin/xcode_project.rb\" project=${PROJECT_FILE} list",
  input: "none",
  keyEquivalent: "^X",
  name: "List Files in Active Target",
  output: "showAsTooltip",
  uuid: "F1FD7DF4-975A-4832-8A52-873AA0D32C44"},
 {beforeRunningCommand: "nop",
  command: 
   "#!/usr/bin/env ruby -wKU\n\nSUPPORT       = ENV['TM_SUPPORT_PATH']\nMATE          = \"\#{SUPPORT}/bin/mate\"\n\nrequire \"\#{SUPPORT}/lib/osx/plist\"\nrequire \"\#{SUPPORT}/lib/escape\"\n\nrequire \"cgi\"\nrequire \"fileutils\"\nrequire \"find\"\nrequire \"iconv\"\n\nTEMPLATE_DIRS = [\n  '/Library/Application Support/Apple/Developer Tools/Project Templates',\n  %x{ \"$TM_SUPPORT_PATH/bin/find_app\" Xcode.app }.sub(/Applications\\/Xcode.app$/, 'Library/Xcode/Project Templates'),\n  ENV['HOME'] + '/Library/Application Support/Apple/Developer Tools/Project Templates'\n]\n\nmodule ProcessTemplate\n  module_function\n  \n  def expand(str, variables)\n    str.gsub(/«(DATE|FULLUSERNAME|ORGANIZATIONNAME|PRODUCTNAME|PROJECTNAMEASIDENTIFIER|PROJECTNAMEASXML|PROJECTNAME|TARGETNAMEASIDENTIFIER|USERNAME|UUID|YEAR)»/) do |match|\n      variables[$1]\n    end\n  end\n\n  def expand_file(file, variables)\n    data = IO.read(file)\n\n    open(file, \"w\") do |io|\n      if data[0..1] == \"\\xFE\\xFF\"\n        new_data = expand(Iconv.conv('utf-8', 'utf-16', data), variables)\n        io << Iconv.conv('utf-16', 'utf-8', new_data)\n      elsif mac_roman?(data)\n        io << expand(Iconv.conv('utf-8', 'mac', data), variables)\n      elsif utf8?(data)\n        io << expand(data, variables)\n      else\n        io << data # we probably should not have opened the file for writing\n      end\n    end\n  end\n\n  def mac_roman?(data)\n    data =~ /\\xC7(DATE|FULLUSERNAME|ORGANIZATIONNAME|PRODUCTNAME|PROJECTNAMEASIDENTIFIER|PROJECTNAMEASXML|PROJECTNAME|TARGETNAMEASIDENTIFIER|USERNAME|UUID|YEAR)\\xC8/\n  end\n\n  def utf8?(data)\n    data =~ /«(DATE|FULLUSERNAME|ORGANIZATIONNAME|PRODUCTNAME|PROJECTNAMEASIDENTIFIER|PROJECTNAMEASXML|PROJECTNAME|TARGETNAMEASIDENTIFIER|USERNAME|UUID|YEAR)»/\n  end\n\n  def process(dir, name)\n    variables = {\n      'DATE'                      => Time.now.strftime('%F'),\n      'FULLUSERNAME'              => ENV['TM_FULLNAME'],\n      'ORGANIZATIONNAME'          => ENV['TM_ORGANIZATION_NAME'],\n      'PRODUCTNAME'               => name,\n      'PROJECTNAMEASIDENTIFIER'   => name.gsub(/[^a-zA-Z0-9]/, '_'),\n      'PROJECTNAMEASXML'          => CGI.escapeHTML(name),\n      'PROJECTNAME'               => name,\n      'TARGETNAMEASIDENTIFIER'    => name.gsub(/[^a-zA-Z0-9]/, '_'),\n      'USERNAME'                  => ENV['LOGNAME'],\n      'UUID'                      => `uuidgen`.chomp,\n      'YEAR'                      => Time.now.year,\n    }\n\n    template_info = Find.find(dir) { |path| break path if path =~ /\\/TemplateInfo.plist$/ }\n    exit unless File.exist? template_info.to_s\n\n    data = File.read(template_info)\n    data = Iconv.conv('utf-8', 'mac', data) if mac_roman? data\n\n    plist = OSX::PropertyList.load(data)\n\n    plist['FilesToRename'].each_pair do |key, value|\n      from = File.join(dir, expand(key, variables))\n      to = File.join(dir, expand(value, variables))\n      FileUtils.mv(from, to) if File.exist?(from) && !File.exist?(to)\n    end unless plist['FilesToRename'].nil?\n\n    src_dir = File.split(template_info).first\n    Dir.glob(\"\#{src_dir}/*.*\").each do |file|\n      expand_file(file, variables)\n    end\n\n    dst_dir = src_dir.sub(/(.*\\/)[^\\/]*(\\.[^.])/, \"\\\\1\#{name}\\\\2\")\n    File.delete(template_info)\n    FileUtils.mv(src_dir, dst_dir) if File.exist?(src_dir) && !File.exist?(dst_dir)\n\n    plist['FilesToMacroExpand'].each do |file|\n      variables['FILENAME'] = file\n      expand_file(File.join(dir, expand(file, variables)), variables)\n    end unless plist['FilesToMacroExpand'].nil?\n  end\nend\n\ndef scan_dir(dir)\n  entries = [ ]\n  Dir.foreach(dir) do |entry|\n    next unless File.directory?(dir) and entry !~ /^\\./\n    entries << { 'name' => entry, 'path' => File.join(dir, entry) }\n  end\n  entries \nend\n\ntemplates = [ ]\n\nTEMPLATE_DIRS.each do |templates_dir|\n  next unless File.directory?(templates_dir)\n  Dir.foreach(templates_dir) do |dir|\n    next if dir =~ /^\\./\n    children = scan_dir(File.join(templates_dir, dir))\n    if template_list = templates.find { |tpl| tpl['name'] == dir }\n      template_list['children'] += children\n    else\n      templates << { 'name' => dir, 'children' => children }\n    end\n  end\nend\n\nplist = { 'templates' => templates, 'projectName' => 'untitled' }.to_plist\ndefaults = { 'Xcode New Project Location'          => '~/',\n             'Xcode New Project Selected Template' => [ [ 1, 6 ] ] }.to_plist\n\nif res = OSX::PropertyList.load(%x{ \"$DIALOG\" -cmp \#{e_sh plist} -d \#{e_sh defaults} 'New Project' })['result']\n\n  src = res['returnArgument']\n\n  dir = File.expand_path(res['location'])\n  dst = File.join(dir, res['name'])\n  \n  abort \"Location does not exist.\"    unless File.exists?(dir)\n  abort \"Destination already exists.\" if File.exists?(dst)\n\n  FileUtils.cp_r(src, dst)\n  ProcessTemplate.process(dst, res['name'])\n  %x{ \#{e_sh MATE} \#{e_sh dst} &>/dev/null & }\n\nend\n",
  input: "none",
  name: "New Project Using Xcode Template…",
  output: "showAsTooltip",
  uuid: "73E356A1-87CF-4B8E-A4B5-B14F29683F12"},
 {beforeRunningCommand: "nop",
  command: 
   "PROJECT=$(ruby -- \"${TM_BUNDLE_SUPPORT}/bin/find_xcode_project.rb\")\nif [[ -f \"${PROJECT}/project.pbxproj\" ]]; then\n   open -a Xcode \"${PROJECT}\"\nelse\n   echo \"Didn't find an Xcode project file.\"\n   echo \"You may want to set TM_XCODE_PROJECT.\"\nfi\n",
  input: "none",
  keyEquivalent: "~@",
  name: "Open Project in Xcode",
  output: "showAsTooltip",
  scope: "source.c, source.c++, source.objc, source.objc++",
  uuid: "C9FAE873-96D3-4CE7-8DDA-4C2B30F1813E"},
 {beforeRunningCommand: "nop",
  command: 
   "PROJECT=$(ruby -- \"${TM_BUNDLE_SUPPORT}/bin/find_xcode_project.rb\")\nif [[ -f \"${PROJECT}/project.pbxproj\" ]]; then\n   \"${TM_BUNDLE_SUPPORT}/bin/run_xcode_target.rb\" -project_dir=\"$PROJECT\"\nelse\n   echo \"Didn't find an Xcode project file.\"\n   echo \"You may want to set TM_XCODE_PROJECT.\"\nfi\n",
  input: "none",
  keyEquivalent: "@R",
  name: "Run",
  output: "showAsTooltip",
  uuid: "779DEA3C-D310-4B66-9531-DF9007434878"},
 {beforeRunningCommand: "nop",
  command: 
   "export TM_TARGET=\"${TM_TEST_TARGET:-Test}\"\n\"${TM_BUNDLE_SUPPORT}/bin/run_xcodebuild.sh\"",
  input: "none",
  keyEquivalent: "~@T",
  name: "Run Tests",
  output: "showAsHTML",
  uuid: "40D3C674-40A1-42A1-847A-FBEAE6E83CCC"}]
