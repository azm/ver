# Encoding: UTF-8

[{beforeRunningCommand: "nop",
  command: 
   "#!/bin/bash\n\n# Use ps to test for Help Viewer, because if we try\n# to use osascript, then it will open Help Viewer\n# before the test, during script compilation.\n\nif ps -xc|grep -sq 'Help Viewer$'; then\n\tosascript -e 'tell application \"Help Viewer\" to open \"file:///\"'\nfi\nosascript <<-APPLESCRIPT\n\ttell app \"Help Viewer\"\n\t    handle url \"file:///Library/Documentation/Help/AppleScript.help/Contents/Resources/English.lproj/AppleScript.html\"\n\t    activate\n\tend tell\t\nAPPLESCRIPT",
  fallbackInput: "scope",
  input: "none",
  keyEquivalent: "^h",
  name: "AppleScript Help",
  output: "discard",
  scope: "source.applescript",
  uuid: "2061AB22-C557-4C68-919E-9A8815577987"},
 {beforeRunningCommand: "nop",
  command: 
   "#!/bin/bash\n\n# If there is a local copy of the Applescript\n# documentation, open it.  Otherwise, use the\n# online copy.\n\nif [ -d \"/Developer/ADC Reference Library/documentation/AppleScript/Conceptual/AppleScriptLangGuide/\" ]; then\n\topen \"file:///Developer/ADC%20Reference%20Library/documentation/AppleScript/Conceptual/AppleScriptLangGuide/index.html\"\nelse\n\topen \"http://developer.apple.com/documentation/AppleScript/Conceptual/AppleScriptLangGuide/\"\nfi\n",
  fallbackInput: "scope",
  input: "none",
  keyEquivalent: "^h",
  name: "AppleScript Language Guide",
  output: "discard",
  scope: "source.applescript",
  uuid: "C744043F-79AE-47D7-9E7A-F476F44437AC"},
 {beforeRunningCommand: "nop",
  command: 
   "#!/bin/bash\n\n# The AppleScript Reference Library at the Apple Developer Connection.\n\nopen \"https://developer.apple.com/referencelibrary/ScriptingAutomation/idxAppleScript-date.html\"\n",
  fallbackInput: "scope",
  input: "none",
  keyEquivalent: "^h",
  name: "AppleScript Reference Library",
  output: "discard",
  scope: "source.applescript",
  uuid: "1A8892FB-D466-492D-A35C-DFF2C6168174"},
 {beforeRunningCommand: "nop",
  command: 
   "#!/bin/bash\n\n# The AppleScript Release Notes at apple.com\n\nopen \"http://developer.apple.com/releasenotes/AppleScript/RN-AppleScript/\"\n",
  fallbackInput: "scope",
  input: "none",
  keyEquivalent: "^h",
  name: "AppleScript Release Notes",
  output: "discard",
  scope: "source.applescript",
  uuid: "E26E1CA5-D173-48A3-853C-D9E962550F8E"},
 {beforeRunningCommand: "nop",
  command: 
   "#!/bin/bash\n\n# A list of useful applescript resources at apple.com\n\nopen \"http://developer.apple.com/applescript/\"\n",
  fallbackInput: "scope",
  input: "none",
  keyEquivalent: "^h",
  name: "AppleScript Resources",
  output: "discard",
  scope: "source.applescript",
  uuid: "023F99B6-3F0B-4249-96E8-39CF824F1733"},
 {beforeRunningCommand: "nop",
  command: 
   "#!/bin/bash\n\n# a list of all built-in terms, their types, and the associated event codes.\n\nopen \"http://developer.apple.com/releasenotes/AppleScript/ASTerminology_AppleEventCodes/TermsAndCodes.html\"\n",
  fallbackInput: "scope",
  input: "none",
  keyEquivalent: "^h",
  name: "AppleScript Terminology / Event Codes",
  output: "discard",
  scope: "source.applescript",
  uuid: "0823F607-CC45-4AB7-A869-36DF8ED662A7"},
 {beforeRunningCommand: "nop",
  command: 
   "#!/usr/bin/env ruby\n\nrequire \"tempfile\"\nrequire ENV[\"TM_SUPPORT_PATH\"] + \"/lib/tm/executor\"\nrequire ENV[\"TM_SUPPORT_PATH\"] + \"/lib/tm/save_current_document\"\n\nTextMate.save_current_document\nTextMate::Executor.make_project_master_current_document\n\nerror_fd = nil\ndocument = File.read(ENV[\"TM_FILEPATH\"])\n\nTempfile::open('tm_osacompile') do |tmpfile|\n  TextMate::Executor.run(ENV[\"TM_OSACOMPILE\"] || \"osacompile\", \"-o\", tmpfile.path, ENV[\"TM_FILEPATH\"], :verb => \"Compiling\", :use_hashbang => false, :version_args => [\"-o\", tmpfile.path, \"-e\", \"nil\"]) do |str, type|\n    error_fd ||= IO.for_fd(ENV[\"TM_ERROR_FD\"].to_i)\n    case type\n    when :err\n      if str =~ /^([^\\:]+):(\\d+):(\\d+): (.*?): (.*) \\((-?\\d+)\\)$/ then\n        filepath, start,  stop, err, msg, status = $1, $2.to_i, $3.to_i, $4, $5, $6\n    \n        err = err.gsub(/\\b\\w(?=\\w{3,})/) { |m| m.upcase }\n      \n        error_fd << \"<div id=\\\"exception_report\\\" class=\\\"framed\\\">\\n\"\n        error_fd << \"<p id=\\\"exception\\\"><strong>\#{htmlize err}</strong>: \#{htmlize msg}</p>\\n\"\n    \n        from = document[0..start].rindex(/^/)\n        to = start + document[start..-1].index(/$/)\n        src =  document[from...to]\n    \n        line = document[0...start].count(\"\\n\") + 1\n        column = start - from\n    \n        link = \"txmt://open?line=\#{line}&column=\#{column}\"\n        error_fd << \"<pre>\#{src}\\n\"\n        error_fd << \"\#{' ' * (column)}↑</pre>\"\n        error_fd <<  \"<blockquote><a href=\\\"\#{link}\\\">line \#{line}, column \#{column}</a> in \#{ENV['TM_DISPLAYNAME']}\\n\"\n    \n        error_fd << \"<p>Error \#{status}.</p>\\n\"\n        error_fd << \"</div>\\n\"\n      \n        error_fd.flush\n        \"\"\n      elsif str =~ /^([^\\:]+):(\\d+): (.*) \\((-?\\d+)\\)$/ then\n        filepath, line, msg, status = $1, $2.to_i, $3, $4\n    \n        error_fd << \"<div id=\\\"exception_report\\\" class=\\\"framed\\\">\\n\"\n        error_fd << \"<p id=\\\"exception\\\"><strong>Error</strong>: \#{htmlize msg}</p>\\n\"\n    \n        src =  document.split(/\\n/)[line - 1]\n    \n        link = \"txmt://open?line=\#{line}\"\n        error_fd << \"<pre>\#{src}</pre>\"\n        error_fd <<  \"<blockquote><a href=\\\"\#{link}\\\">line \#{line}</a> in \#{ENV['TM_DISPLAYNAME']}\\n\"\n    \n        error_fd << \"<p>Error \#{status}.</p>\\n\"\n        error_fd << \"</div>\\n\"\n      \n        error_fd.flush\n        \"\"\n      else\n        \"<span class=\\\"err\\\" style=\\\"color:red;\\\">\#{htmlize(str)}</span><br/>\"\n      end\n    when :out\n      htmlize(str)\n    end\n  end\nend\n",
  input: "document",
  keyEquivalent: "@b",
  name: "Compile",
  output: "showAsHTML",
  scope: "source.applescript",
  uuid: "FAA71813-1CC3-45BC-BDC4-EE388D80746C"},
 {beforeRunningCommand: "nop",
  command: 
   "#!/bin/bash\n\ncontent () {\n\ticonv -cs -f utf-8 -t macroman//TRANSLIT | perl -pe 's/[\"\\\\]/\\\\$&/g'\n}\n\nosascript <<-APPLESCRIPT\n\ttell application \"Script Editor\"\n\t    activate\n\t    set theDocument to make new document\n\t    tell theDocument\n\t        set contents of selection to \"$(content)\"\n\t        try\n\t            check syntax\n\t            compile\n\t        on error error_message number the error_number\n\t            display dialog \"Error: \" & the error_number & \". \" & the error_message buttons {\"OK\"} default button 1\n\t        end try\n\t    end tell\n\tend tell\nAPPLESCRIPT",
  input: "selection",
  keyEquivalent: "~@b",
  name: "Compile in Script Editor",
  output: "showAsTooltip",
  scope: "source.applescript",
  uuid: "E3DD341F-94E6-460C-8EDA-D1184B67866F"},
 {beforeRunningCommand: "nop",
  command: 
   "#!/bin/bash\n\nif sed -n \"$((TM_LINE_NUMBER-1))p\" | grep -sq '¬$'; then\n\techo -ne '¬\\n'\nelse\n\techo -ne '¬\\n\\t'\nfi\n",
  input: "document",
  keyEquivalent: "",
  name: "Continue Line (¬)",
  output: "insertAsSnippet",
  scope: "source.applescript",
  uuid: "9755F5E9-3919-4E82-AAAD-9ECB64FD718A"},
 {beforeRunningCommand: "nop",
  command: 
   "#!/usr/bin/env ruby -KA -ruri\n\nsrc = 'applescript://com.apple.scripteditor?action=new&script='\nsrc << URI.encode(STDIN.read)\n\nopen('|pbcopy', 'w') { |io| io << src }\n\nprint \"The URL encoded AppleScript was copied to the clipboard\"\n",
  fallbackInput: "document",
  input: "selection",
  keyEquivalent: "^@C",
  name: "Copy URL Encoded Script",
  output: "showAsTooltip",
  scope: "source.applescript",
  uuid: "565860C4-A665-4C64-81B0-CA7848B181A2"},
 {beforeRunningCommand: "nop",
  command: 
   "#!/bin/bash\n\nread appname\nosascript <<-APPLESCRIPT\n\ttell app \"Script Editor\"\n\t    launch\n\t    activate\n\t    open path to application ${appname}\n\tend tell\nAPPLESCRIPT\n",
  fallbackInput: "scope",
  input: "selection",
  keyEquivalent: "^h",
  name: "Documentation for Application",
  output: "discard",
  scope: "string.quoted.double.application-name.applescript",
  uuid: "2263B3B6-8D09-4B98-B056-3DF129226C78"},
 {beforeRunningCommand: "nop",
  command: 
   "#!/usr/bin/env ruby -wKU\n\ndef end_what?\n  ENV[\"TM_SCOPE\"].split.reverse_each do |scope|\n    case scope\n    when /^meta\\.function\\./\n      return 'end'\n    when /^meta\\.block\\.(\\w+)\\./\n      return \"end \#{$1}\"\n    end\n  end\nend\n\nputs end_what?\n",
  input: "none",
  keyEquivalent: "~@.",
  name: "End Block",
  output: "afterSelectedText",
  scope: "source.applescript meta.block, source.applescript meta.function",
  uuid: "99F1A4C2-2156-4F24-902C-0F651B293ECE"},
 {beforeRunningCommand: "nop",
  command: 
   "#!/bin/bash\n\n# A list of useful AppleScript Resources at\n# macosxautomation.com\n\n# open \"http://www.macosxautomation.com/applescript/\"\n",
  fallbackInput: "scope",
  input: "none",
  keyEquivalent: "^h",
  name: "Mac OS X Automation Resources",
  output: "discard",
  scope: "source.applescript",
  uuid: "BA54AD1A-04AC-4CD1-B282-7F65D58EFE2B"},
 {beforeRunningCommand: "nop",
  command: 
   "#!/bin/bash\n\n# Turn the selected text into a function with\n# positional arguments.\n\nNAME=\"$(cat)\"\nif [[ -z \"$NAME\" ]]; then\n\tNAME='${1:function_name}'\nfi\n\ncat <<SNIPPET\non $NAME(\\${2:arguments})\n\t\\${0:-- statements}\nend $NAME\nSNIPPET\n",
  fallbackInput: "word",
  input: "selection",
  keyEquivalent: "$\n",
  name: "New Function",
  output: "insertAsSnippet",
  scope: "source.applescript",
  tabTrigger: "on",
  uuid: "883C87A4-C370-4C92-9307-3C46380EE12F"},
 {beforeRunningCommand: "nop",
  command: 
   "#!/usr/bin/env ruby\n\nrequire ENV[\"TM_SUPPORT_PATH\"] + \"/lib/tm/executor\"\nrequire ENV[\"TM_SUPPORT_PATH\"] + \"/lib/tm/save_current_document\"\n\nTextMate.save_current_document\nTextMate::Executor.make_project_master_current_document\n\nerror_fd = nil\ndocument = File.read(ENV[\"TM_FILEPATH\"])\n\nTextMate::Executor.run(ENV[\"TM_OSASCRIPT\"] || \"osascript\", \"-ss\", ENV[\"TM_FILEPATH\"], :version_args => [\"-e\", \"\\\"AppleScript \\\" & (AppleScript's version as string)\"]) do |str, type|\n  error_fd ||= IO.for_fd(ENV[\"TM_ERROR_FD\"].to_i)\n  case type\n  when :err\n    if str =~ /^([^\\:]+):(\\d+):(\\d+): (.*?): (.*) \\((-?\\d+)\\)$/ then\n      filepath, start,  stop, err, msg, status = $1, $2.to_i, $3.to_i, $4, $5, $6\n    \n      err = err.gsub(/\\b\\w(?=\\w{3,})/) { |m| m.upcase }\n      \n      error_fd << \"<div id=\\\"exception_report\\\" class=\\\"framed\\\">\\n\"\n      error_fd << \"<p id=\\\"exception\\\"><strong>\#{htmlize err}</strong>: \#{htmlize msg}</p>\\n\"\n    \n      from = document[0..start].rindex(/^/)\n      to = start + document[start..-1].index(/$/)\n      src =  document[from...to]\n    \n      line = document[0...start].count(\"\\n\") + 1\n      column = start - from\n    \n      link = \"txmt://open?line=\#{line}&column=\#{column}\"\n      error_fd << \"<pre>\#{src}\\n\"\n      error_fd << \"\#{' ' * (column)}↑</pre>\"\n      error_fd <<  \"<blockquote><a href=\\\"\#{link}\\\">line \#{line}, column \#{column}</a> in \#{ENV['TM_DISPLAYNAME']}\\n\"\n    \n      error_fd << \"<p>Error \#{status}.</p>\\n\"\n      error_fd << \"</div>\\n\"\n      \n      error_fd.flush\n      \"\"\n    else\n      \"<span class=\\\"err\\\" style=\\\"color:red;\\\">\#{htmlize(str)}</span><br/>\"\n    end\n  when :out\n    htmlize(str)\n  end\nend\n",
  input: "document",
  keyEquivalent: "@r",
  name: "Run",
  output: "showAsHTML",
  scope: "source.applescript",
  uuid: "28D28F3B-C59B-4387-A67E-65CFF1CBC62B"},
 {beforeRunningCommand: "nop",
  command: 
   "#!/usr/bin/env ruby\n\nscrpt = STDIN.read\n\nif scrpt =~ /\\A\\s*osascript\\s+-e\\s*(.*)\\z/m then\n  scrpt = $1.gsub(/\\s+-e\\s*/, \"\\n\")\n  scrpt.gsub!(/\\\\(')|'([^']*)'/, '\\1\\2')\n  print \"${0:\", scrpt.gsub(/[$`\\\\}]/, '\\\\\\\\\\0'), \"}\"\n  %x{ { sleep .1; osascript -e 'tell app \"System Events\" to keystroke \"[\" using {command down, option down}'; } &>/dev/null & } # Indent Selection\n  exit 204 # this signals exit_insert_as_snippet\nelse\n  lines = scrpt.collect { |line| line.chomp.gsub(/'/, \"'\\\\\\\\''\") }\n  lines.collect! { |line| \"-e '\#{line.strip}'\" }\n  print \"osascript \" + lines.join(' ')\nend\n",
  fallbackInput: "line",
  input: "selection",
  keyEquivalent: "^H",
  name: "Toggle AppleScript / osascript",
  output: "replaceSelectedText",
  scope: "source.applescript, source.shell",
  uuid: "B85D7CB4-5A47-4B49-831F-F2CCBFC5F48F"},
 {beforeRunningCommand: "nop",
  command: 
   "#!/usr/bin/env ruby\n\n# AppleScript strings cannot handle Unicode text, so\n# any Unicode characters entered in a string will\n# simply be dropped when the script is run.  However,\n# a Unicode text object obviously has no trouble\n# accepting any characters.  This command toggles\n# between raw unicode data and a \" delimited string,\n# to simplify the creation of Unicode text objects.\n\ncase txt = STDIN.read\n  when /\\A«data utxt([0-9A-F]+)»(?: as Unicode text)?\\z/i then\n    decoded = $1.gsub(/([0-9A-F]{4})/i) { |m| [$1.hex].pack(\"U\") }\n    print '\"' + decoded + '\"'\n\n  when /\\A«data utf8([0-9A-F]+)»(?: as Unicode text)?\\z/i then\n    decoded = $1.gsub(/../) { |i| i.hex.chr }\n    print '\"' + decoded + '\"'\n\n  when /\\A\"(.*)\"\\z/ then\n    encoded = \"\"\n    $1.each_byte { |b| encoded << format(\"%02X\", b) }\n    print '«data utf8' + encoded + '» as Unicode text'\n\n  else\n    print txt\nend\n",
  fallbackInput: "scope",
  input: "selection",
  keyEquivalent: "^\"",
  name: "Toggle String / «data utf8»",
  output: "replaceSelectedText",
  scope: 
   "string.quoted.double.applescript, constant.other.data.utxt.applescript",
  uuid: "7B6716C8-A890-4803-8C61-5E31F1A4BE63"}]
