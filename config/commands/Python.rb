# Encoding: UTF-8

[{beforeRunningCommand: "nop",
  command: 
   "\"${TM_PYTHON:-python}\" \"${TM_BUNDLE_SUPPORT}/cleanup_whitespace.py\"",
  input: "selection",
  name: "Cleanup Whitespace",
  output: "replaceSelectedText",
  scope: "source.python",
  uuid: "95FFEECE-73E4-4B33-9CAE-1641C62FFBC0"},
 {beforeRunningCommand: "nop",
  bundleUUID: "E3BADC20-6B0E-11D9-9DC9-000D93589AF6",
  command: 
   "#!/usr/bin/env python\nimport sys\nimport re\nimport os\n\nre_symbol = re.compile(r\"^(\\s*)(?:class|def)\\s+([a-zA-Z_][a-zA-Z_0-9]*)\\s*[\\:\\(]\")\ntm_line_num = int(os.environ['TM_LINE_NUMBER'])\nline_num = 0\n\nsymbols = []\nfor line in sys.stdin:\n    line_num += 1\n    m = re_symbol.search(line)\n    if m:\n        ws, name = m.groups()\n        ws_len = len(ws.expandtabs())\n        while symbols and symbols[-1][0] >= ws_len:\n            symbols.pop()\n        symbols.append((ws_len, name))\n    if line_num == tm_line_num:\n        break\n\nsymbol = '.'.join([t[1] for t in symbols])\np = os.popen(\"/usr/bin/pbcopy\", \"w\")\np.write(symbol)\np.close()\n\n",
  input: "document",
  keyEquivalent: "^~c",
  name: "Copy Symbol",
  output: "discard",
  scope: "source.python",
  uuid: "3AFD7429-7123-4ADD-B3CC-A9F112F8643B"},
 {beforeRunningCommand: "nop",
  command: 
   "# start up Python in debug mode using either Terminal.app or iTerm.app\n# according to the user's value for TM_TERM_PROG\n# Default to Terminal.app since that is standard.\nTP=${TM_TERM_PROG:=Terminal}\nTPY=${TM_PYTHON:=python}\n\nif [ \"$TP\" == iTerm ]; then\n    osascript <<END\n        tell application \"iTerm\"\n            activate\n            set myterm to (the first terminal)\n            tell myterm            \n                set mysession to (make new session at the end of sessions)\n                tell mysession\n                    exec command \"/bin/bash -c \\\"$TPY -m pdb '$TM_FILEPATH' \\\" \" \n                end tell\n            end tell\n        end tell\nEND\nelse\n    osascript  <<END2\n        tell application \"Terminal\"\n            activate\n            do script with command \"$TPY -m pdb '$TM_FILEPATH'\"\n        end tell\nEND2\nfi\n",
  input: "none",
  keyEquivalent: "@D",
  name: "Debug Script in Terminal",
  output: "discard",
  scope: "source.python",
  uuid: "504278F6-89F4-11D9-9326-000D93B6E43C"},
 {beforeRunningCommand: "nop",
  command: 
   "# set up TM_FIRST_LINE containing the first line of the script.\nread first_line\n0<&- # close STDIN\nexport TM_FIRST_LINE=\"$first_line\"\n\nexport PYTHONPATH=\"$TM_BUNDLE_SUPPORT/DocMate\"\nexport PYTHONPATH=\"$TM_SUPPORT_PATH/lib:$PYTHONPATH\"\n\n/usr/bin/env python -S - <<PYTHON\n# coding: UTF-8\nimport sys\nfrom sys import exit\n\nimport tm_helpers\nimport webpreview\nimport docmate\nimport dialog\n\ndocmate.launch_pydoc_server()\n\n# get current dotted word from the env\nword = tm_helpers.current_word(r\"[A-Za-z0-9_\\.]*\")\n\nif not word:\n    print \"<meta http-equiv='Refresh' content='0;URL=%s'>\" % docmate.pydoc_url()[0]\nelse:\n    library_docs = docmate.library_docs(word)\n    local_docs = docmate.local_docs(word)\n    if library_docs:\n        print webpreview.html_header(\"DocMate\", \"Python\")\n        print \"<h3>Python Library Documentation</h3>\\n\"\n        print \"<ol style='list-style-type: lower-alpha;'>\\n\"\n        for n, opt in enumerate(library_docs):\n            desc, url = opt\n            accesskey = chr(ord(\"a\") + n)\n            print '\\t<li><a href=\"%s\" accesskey=\"%s\">%s</a></li>\\n' % (url, accesskey, desc)\n        print \"</ol>\\n\"\n    if local_docs and library_docs:\n        print \"<h3>Pydoc Documentation</h3>\"\n        print \"<ol style='list-style-type: decimal;'>\\n\"\n        for n, opt in enumerate(local_docs):\n            desc, url = opt\n            accesskey = chr(ord(\"1\") + n)\n            print '\\t<li><a href=\"%s\" accesskey=\"%s\">%s</a></li>\\n' % (url, accesskey, desc)\n        print \"</ol>\\n\"\n        print webpreview.html_footer()\n    elif local_docs and not library_docs:\n        print \"<meta http-equiv='Refresh' content='0;URL=%s'>\" % local_docs[0][1]\n    else:\n        print \"<meta http-equiv='Refresh' content='0;URL=%s'>\" % docmate.pydoc_url()[0]\nPYTHON\n",
  input: "document",
  keyEquivalent: "^h",
  name: "Documentation for Current Word",
  output: "showAsHTML",
  scope: "source.python",
  uuid: "443BBF21-6124-4486-BFCA-D18606465885"},
 {beforeRunningCommand: "nop",
  command: 
   "# This command takes the currently selected word and\n# displays the python documentation for the module\n# corresponding to said word.\n#\n# It falls back on the current word.\n\n# change to /tmp to avoid possibly overwriting\n# an html file in the working directory.\ncd /tmp\n\n: ${TM_SELECTED_TEXT:=$TM_CURRENT_WORD}\npydoc -w \"$TM_SELECTED_TEXT\" >/dev/null\nif [[ -f \"$TM_SELECTED_TEXT.html\" ]]; then\n\tcat \"$TM_SELECTED_TEXT.html\"\n\trm -f \"$TM_SELECTED_TEXT.html\"\nelse\n\techo \"<p>No documentation found for:<pre>$TM_SELECTED_TEXT</pre><p>This command only looks for Python modules.\"\nfi\n",
  input: "none",
  keyEquivalent: "",
  name: "Documentation for Module",
  output: "showAsHTML",
  scope: "source.python",
  uuid: "5BBD932E-7BB0-11D9-8E83-000D93B6E43C"},
 {beforeRunningCommand: "nop",
  command: 
   "TPY=${TM_PYTHON:-python}\n\necho '<html><body>'\n\"$TPY\" \"${TM_BUNDLE_SUPPORT}/browse_pydocs.py\"\necho '</body></html>'",
  input: "none",
  keyEquivalent: "^H",
  name: "Documentation in Browser",
  output: "showAsHTML",
  scope: "source.python",
  uuid: "095E8342-FAED-4B95-A229-E245B0B601A7"},
 {beforeRunningCommand: "nop",
  command: 
   "#!/usr/bin/env python\n\nimport os\nfrom sys import stdout, stdin, exit\nfrom traceback import format_stack\n\npy = stdin.read()\n\nif 'TM_SELECTED_SCOPE' in os.environ:\n    stdout.write(\" \")\nelse:\n    stdout.write(\"\\n\")\n\ntry:\n    scope = {}\n    result = eval(py, globals(), scope)\nexcept:\n    exc = format_stack()\n    stdout.write(exc)\n    exit(206) # exiting with this code show's output in a tooltip \nelse:\n    stdout.write(repr(result))\n\n",
  fallbackInput: "line",
  input: "selection",
  keyEquivalent: "^E",
  name: "Execute Line/Selection as Python",
  output: "afterSelectedText",
  scope: "source.python",
  uuid: "09E7930D-E706-4C90-B37E-5B95E1D97949"},
 {beforeRunningCommand: "nop",
  command: 
   "#!/usr/bin/env python -S\n# coding: utf-8\n\n# This program takes in the name of one of python's special methods, and\n# spits a snippet out.  If the name is unknown, make a regular (non-magic)\n# method/function\n\n# these functions take no argument except 'self'\nselfList = (\n    'del', 'repr', 'str', 'hash', 'nonzero', 'unicode', 'len', 'iter', 'neg',\n    'pos', 'abs', 'invert', 'complex', 'int', 'long', 'float', 'oct', 'hex',\n    'index', 'enter'\n)\n# these binary operators take both 'self' and 'other' as arguments\nselfOtherList = (\n 'lt', 'le', 'eq', 'ne', 'gt', 'ge', 'cmp', 'add', 'sub', 'mul', 'floordiv',\n 'mod', 'divmod', 'lshift', 'rshift', 'and', 'xor', 'or', 'div', 'truediv',\n 'radd', 'rsub', 'rmul', 'rdiv', 'rtruediv', 'rfloordiv', 'rmod', 'rdivmod',\n 'rpow', 'rlshift', 'rrshift', 'rand', 'rxor', 'ror', 'iadd', 'isub', 'imul',\n 'idiv', 'itruediv', 'ifloordiv', 'imod', 'ilshift', 'irshift', 'iand',\n 'ixor', 'ior', 'coerce', 'pow', 'ipow'\n)\n# these functions take some argument(s) other than self\nselfAndMore = {\n         'getattr' : 'name',\n         'delattr' : 'name',\n    'getattribute' : 'name',\n         'setattr' : 'name, value',\n         'getitem' : 'key',\n         'delitem' : 'key',\n         'setitem' : 'key, value',\n             'get' : 'instance, owner',\n             'set' : 'instance, value',\n          'delete' : 'instance',\n        'contains' : 'item',\n        'setslice' : 'i, j, sequence',\n        'delslice' : 'i, j',\n            'exit' : 'exc_type, exc_value, traceback',\n}\n\nsPass = '\\t${4/.+/\"\"\"/}${4:docstring for %s}${4/.+/\"\"\"\\n/}${4/.+/\\t/}${0:pass}'\n\ndef defLine(func, args):\n    return ''.join([\"def __\", func, \"__(\", args, \"):\\n\", sPass])\n\ndef make_snippet(name):\n    if name in selfList:\n        return defLine(name, 'self')\n    \n    elif name in selfOtherList:\n        return defLine(name, 'self, other')\n    \n    elif name in selfAndMore:\n        return defLine(name, 'self, ' + selfAndMore[name])\n    \n    elif name in ('init', 'call', 'new'):\n        return defLine(name, 'self${2/([^,])?.*/(?1:, )/}${2:arg}')\n        \n    else:\n        return ''.join(['def ', name, '(${3:self${2/([^,])?.*/(?1:, )/}${2:arg}}):\\n', sPass % name])\n\n# actually print the thing out, using the current word in TM\nfrom os import environ as env\nfrom sys import exit\ntry:\n    print make_snippet(env['TM_CURRENT_WORD'])\nexcept KeyError:\n    print 'Please type the new function\\'s name\\n(you can also use def⇥).'\n    exit(206)",
  fallbackInput: "word",
  input: "selection",
  keyEquivalent: "$\n",
  name: "New Method/Function",
  output: "insertAsSnippet",
  scope: "source.python",
  uuid: "75929BC0-24E5-456D-9FC5-91BF4B490027"},
 {beforeRunningCommand: "saveModifiedFiles",
  captureFormatString: "Line $2 in $1",
  capturePattern: "^\\s*File \"(.+)\", line (\\d+)",
  command: 
   "# Find all files that end with \"Test.py\" and run \n# them.\n\nfind . -name \"*Test.py\" -exec \"${TM_PYTHON:-python}\" '{}' \\;|pre",
  fileCaptureRegister: "1",
  input: "none",
  keyEquivalent: "~@R",
  lineCaptureRegister: "2",
  name: "Run Project Unit Tests",
  output: "showAsHTML",
  scope: "source.python",
  uuid: "1FAC4AE2-B00C-11D9-91F2-000D93347A42"},
 {autoScrollOutput: true,
  beforeRunningCommand: "nop",
  command: 
   "#!/usr/bin/env ruby\nrequire ENV[\"TM_SUPPORT_PATH\"] + \"/lib/tm/executor\"\nrequire ENV[\"TM_SUPPORT_PATH\"] + \"/lib/tm/save_current_document\"\n\nTextMate.save_current_document\nTextMate::Executor.make_project_master_current_document\n\nENV[\"PYTHONPATH\"] = ENV[\"TM_BUNDLE_SUPPORT\"] + (ENV.has_key?(\"PYTHONPATH\") ? \":\" + ENV[\"PYTHONPATH\"] : \"\")\n\nis_test_script = ENV[\"TM_FILEPATH\"] =~ /(?:\\b|_)(?:test)(?:\\b|_)/ or\n                 File.read(ENV[\"TM_FILEPATH\"]) =~ /\\bimport\\b.+(?:unittest)/\n\nTextMate::Executor.run(ENV[\"TM_PYTHON\"] || \"python\", \"-u\", ENV[\"TM_FILEPATH\"]) do |str, type|\n  if is_test_script and type == :err\n    if str =~ /\\A[\\.F]*\\Z/\n      str.gsub!(/(\\.|F)/, \"<span class=\\\"test ok\\\">\\\\1</span>\")\n      str + \"<br/>\\n\"\n    elsif str =~ /\\A(FAILED.*)\\Z/\n      \"<div class=\\\"test fail\\\">\#{htmlize $1}</div>\\n\"\n    elsif str =~ /\\A(OK.*)\\Z/\n      \"<div class=\\\"test ok\\\">\#{htmlize $1}</div>\\n\"\n    elsif str =~ /^(\\s+)File \"(.+)\", line (\\d+), in (.*)/\n      indent = $1\n      file   = $2\n      line   = $3\n      method = $4\n      indent += \" \" if file.sub!(/^\\\"(.*)\\\"/,\"\\1\")\n      url = \"&amp;url=file://\" + e_url(file)\n      display_name = ENV[\"TM_DISPLAYNAME\"]\n      \"\#{htmlize(indent)}<a class=\\\"near\\\" href=\\\"txmt://open?line=\#{line + url}\\\">\" +\n        (method ? \"method \#{CGI::escapeHTML method}\" : \"<em>at top level</em>\") +\n        \"</a> in <strong>\#{CGI::escapeHTML display_name}</strong> at line \#{line}<br/>\\n\"\n    end\n  end\nend",
  input: "document",
  keyEquivalent: "@r",
  name: "Run Script",
  output: "showAsHTML",
  scope: "source.python",
  uuid: "D1C3D420-2DC5-4C61-9586-00E76A6C054B"},
 {beforeRunningCommand: "nop",
  command: 
   "#!/bin/bash\n[[ -z \"$TM_FILEPATH\" ]] && TM_TMPFILE=$(mktemp -t pythonInTerm)\n: \"${TM_FILEPATH:=$TM_TMPFILE}\"; cat >\"$TM_FILEPATH\"\n\nTPY=${TM_PYTHON:-pythonw}\n\nesc () {\nSTR=\"$1\" ruby <<\"RUBY\"\n   str = ENV['STR']\n   str = str.gsub(/'/, \"'\\\\\\\\''\")\n   str = str.gsub(/[\\\\\"]/, '\\\\\\\\\\\\0')\n   print \"'\#{str}'\"\nRUBY\n}\n\nosascript <<- APPLESCRIPT\n\ttell app \"Terminal\"\n\t    launch\n\t    activate\n\t    do script \"clear; cd $(esc \"${TM_DIRECTORY}\"); $(esc \"${TPY}\") $(esc \"${TM_FILEPATH}\"); rm -f $(esc \"${TM_TMPFILE}\")\"\n\t    set position of first window to { 100, 100 }\n\tend tell\nAPPLESCRIPT\n\n",
  input: "document",
  keyEquivalent: "@R",
  name: "Run Script (Terminal)",
  output: "discard",
  scope: "source.python",
  uuid: "1EFE7452-E7BC-4662-874B-8E4C0FCCF45B"},
 {beforeRunningCommand: "nop",
  bundleUUID: "E3BADC20-6B0E-11D9-9DC9-000D93589AF6",
  command: 
   "#!/usr/bin/env python\nimport sys\nimport re\nimport os\n\nre_symbol = re.compile(r\"^(\\s*)(?:class|def)\\s+([a-zA-Z_][a-zA-Z_0-9]*)\\s*[\\:\\(]\")\ntm_line_num = int(os.environ['TM_LINE_NUMBER'])\nline_num = 0\n\nsymbols = []\nfor line in sys.stdin:\n    line_num += 1\n    m = re_symbol.search(line)\n    if m:\n        ws, name = m.groups()\n        ws_len = len(ws.expandtabs())\n        while symbols and symbols[-1][0] >= ws_len:\n            symbols.pop()\n        symbols.append((ws_len, name))\n    if line_num == tm_line_num:\n        break\n\nsymbol = '.'.join([t[1] for t in symbols])\nprint symbol",
  input: "document",
  keyEquivalent: "^~p",
  name: "Show Symbol",
  output: "showAsTooltip",
  scope: "source.python",
  uuid: "86BCD309-37C2-4978-B332-EC91AEF70340"},
 {beforeRunningCommand: "saveActiveFile",
  capturePattern: "^(.*)\\s+line:\\s+(\\d+)\\s+col:\\s+(\\d+).*$",
  columnCaptureRegister: "3",
  command: 
   "TPY=${TM_PYTHON:-python}\n\n\"$TPY\" \"$TM_BUNDLE_SUPPORT/bin/pycheckmate.py\" \"$TM_FILEPATH\"",
  fileCaptureRegister: "1",
  input: "none",
  keyEquivalent: "^V",
  lineCaptureRegister: "2",
  name: "Validate Syntax (PyCheckMate)",
  output: "showAsHTML",
  scope: "source.python",
  uuid: "44C9C59C-89F9-11D9-9326-000D93B6E43C"}]
