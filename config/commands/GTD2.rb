# Encoding: UTF-8

[{beforeRunningCommand: "saveActiveFile",
  command: 
   "#!/usr/bin/env ruby  \n\nrequire \"\#{ENV['TM_SUPPORT_PATH']}/lib/textmate\"\nrequire \"erb\"\nrequire \"pp\"\ninclude ERB::Util\nrequire \"\#{ENV['TM_BUNDLE_SUPPORT']}/gtd_functions\" \n\ndisplayTasks\n",
  input: "none",
  keyEquivalent: "^T",
  name: "Active GTD List View",
  output: "showAsHTML",
  scope: "text.html.markdown.wiki.gtd",
  uuid: "A108E6E4-317A-4883-B152-11A9E115BF1C"},
 {beforeRunningCommand: "nop",
  command: 
   "#!/usr/bin/env ruby\n# just to remind you of some useful environment variables\n# see Help / Environment Variables for the full list\n# echo File: \"$TM_FILEPATH\"\n\narchiveDate = `date +%Y-%m-%d`\nmyArchive = ENV['TM_PROJECT_DIRECTORY'].to_s + '/ArchivedTasks.gtd'\nmyTasks = ''\nmyTask = (`date +%Y-%m-%d`).chomp + \" \" + ENV['TM_FILENAME'][0..-5] + \": \" + ENV['TM_CURRENT_LINE'][3..-1] \n#puts myArchive\n\nunless (File.exists?(myArchive))\n\texec \"touch \#{myArchive}\"\nend \n\nFile.open(myArchive, \"r\").each do |line|\n  myTasks = myTasks + line\nend\n\nmyTasks = myTasks + myTask + \"\\n\"\n\nFile.open(myArchive, \"w\") do |f|\n  f << myTasks\nend",
  fallbackInput: "line",
  input: "selection",
  name: "Archive Task",
  output: "replaceSelectedText",
  scope: "text.html.markdown.wiki.gtd",
  tabTrigger: "a",
  uuid: "7FC498D7-1477-445B-A39B-FA63FDF10742"},
 {beforeRunningCommand: "saveActiveFile",
  command: 
   "#!/usr/bin/env ruby\n\nmyFile = ENV['TM_SELECTED_FILE']\n\nmyText = File.open(myFile)\nre = /\\s/\nmyText.each do |line|\n  #myTest = re.match(line)\n  #if (myTest.pre_match != \"+\" and myTest.pre_match.length > 0)\n  if line.length > 1\n    puts line\n  end\nend",
  input: "document",
  keyEquivalent: "^C",
  name: "Cleanup",
  output: "replaceDocument",
  scope: "text.html.markdown.wiki.gtd",
  uuid: "0CE0800F-C66A-476A-B67A-5B22087D4E70"},
 {beforeRunningCommand: "nop",
  command: 
   "#!/usr/bin/env ruby  \n\nrequire \"\#{ENV['TM_SUPPORT_PATH']}/lib/textmate\"\n\n$myPath = ENV['TM_DIRECTORY']\n\nmyFiles = Dir.entries($myPath)\nmyProjects = []\nmyFiles.each do |fileName|\n  if fileName[-3,3]  == \"gtd\"\n    myProjects.push fileName\n  end\nend\n\nputs myProjects",
  input: "none",
  keyEquivalent: "^P",
  name: "Create Project List",
  output: "replaceDocument",
  scope: "text.html.markdown.wiki.gtd",
  uuid: "DC188528-1C29-47BA-9DBB-29A0C97C5655"},
 {beforeRunningCommand: "nop",
  command: 
   "#!/usr/bin/env python\nimport sys, os\n\noldtask = os.environ['TM_CURRENT_LINE']\nif (oldtask[0] != \"+\") and (oldtask[0] != \"^\"):\n\tsys.stdout.write(\"-> \" + oldtask[3:])\nelse:\n    sys.stdout.write(oldtask)",
  fallbackInput: "line",
  input: "selection",
  name: "Delegate",
  output: "replaceSelectedText",
  scope: "text.html.markdown.wiki.gtd",
  tabTrigger: "f",
  uuid: "DCE997E1-D107-4873-A297-6CF808401DA3"},
 {beforeRunningCommand: "nop",
  command: 
   "#!/usr/bin/env python\nimport sys, os\n\noldtask = os.environ['TM_CURRENT_LINE']\nsys.stdout.write(\"+  \" + oldtask[3:])\n",
  fallbackInput: "line",
  input: "selection",
  name: "Done",
  output: "replaceSelectedText",
  scope: "text.html.markdown.wiki.gtd",
  tabTrigger: "d",
  uuid: "3EA8AD43-5ED3-4FB3-9296-D37A409AABF8"},
 {beforeRunningCommand: "nop",
  command: 
   "#!/usr/bin/env ruby\n\n# To use this function, type the desired key followed by \"Enter\"\n#\n# Note - the search for the tab command will stop at the first match,\n# so put longer commands before shorter, e.g., tw before t.\n\n# This is where the GTD files are kept\n$myPath = ENV['TM_DIRECTORY'] \ntabCommand = ENV['TM_CURRENT_LINE']\n\n$contexts = [] #user defined contexts\ndef readContexts(a)\n  # processes contexts.gtd into script  \n  context, tabCommand, tabString, regex, color = a.split(/\\|/)\n  $contexts.push({:context => tabCommand, :tabString => tabString})   \nend\n\n\ndef reportContexts\n  # a simple test\n  $contexts.each do |tag|\n    puts(\"Context: \" + tag[:context])\n    puts(\"tabCommand: \" + tag[:tabCommand])\n    puts(\"tabString: \" + tag[:tabString])\n    puts(\"Search String: \" + tag[:regex])\n    puts(\"Color: \" + tag[:color])\n    i = 0\n    while i < tag[:tasks].length\n      puts \"Task: \" + tag[:tasks][i]\n      i = i + 1\n    end\n  end\nend\n\ndef myParse tabCommand\n  found = 0\n  $contexts.each do |tag|\n    re = tag[:context]\n    if (tabCommand == re) and (found == 0) \n      print tag[:tabString]\n      found = 1\n    end\n  end\n  if found == 0 \n    puts \"failed\"\n  end\nend\n\n\n# the contexts.gtd file is read, and converted into $contexts\nfile = File.open($myPath+\"/contexts.gtd\", \"r\")\nfile.each do |line|\n  readContexts(line)\nend    \n\nmyParse tabCommand",
  fallbackInput: "line",
  input: "selection",
  keyEquivalent: "",
  name: "Execute Tab Command",
  output: "insertAsSnippet",
  scope: "text.html.markdown.wiki.gtd",
  uuid: "1CEC5F39-6479-4C96-BD24-EF49F0A19F9B"},
 {beforeRunningCommand: "saveActiveFile",
  command: 
   "#!/usr/bin/env ruby  \n\nrequire \"\#{ENV['TM_SUPPORT_PATH']}/lib/textmate\"\nrequire \"erb\"\nrequire \"pp\"\ninclude ERB::Util\nrequire \"\#{ENV['TM_BUNDLE_SUPPORT']}/gtd_functions\" \n\n$myPath = ENV['TM_DIRECTORY'] \n$tags = [] #user defined contexts\n\ndef readContexts(a)\n  # processes contexts.gtd into script  \n  context, tabCommand, tabString, regex, color = a.split(/\\|/)\n  if context != \"+ DONE\"\n    $tags.push({:label => context[3..-1], :regexp => regex, :color => color, :matches => []})  \n  end \nend \n\n# the contexts.gtd file is read, and converted into $contexts\nfile = File.open($myPath+\"/contexts.gtd\", \"r\")\nfile.each do |line|\n  readContexts(line)\nend \n\n# new feature - exclusion of selected files\n# this allows you to select which lists are included\n# in list views\nclass ExList\n  def initialize\n    @values = []\n  end\n  def contains(test)\n    found = true\n    @values.each do |item|\n      if test == item.chomp\n        found = false\n      end\n    end\n    return found\n  end\n  def add(item)\n    @values.push item\n  end\n  def print\n    puts @values\n  end\nend\n\nxFile = File.open($myPath+\"/excluded.gtd\", \"r\")\n\nmyList = ExList.new\n\nxFile.each do |line|\n  myList.add(line)\nend\n\n# sorting happens\ntodoList = \"\"\n$tags.each do |tag| \n  context = tag[:regexp] \n  matches = 0 \n  myFiles = Dir.entries($myPath)\n  myFiles.each do |fileName|\n    if ((fileName[-3,3] == \"gtd\") and myList.contains(fileName))\n      lineno = 0\n      mFile = File.open(fileName) \n      mFile.each do |line|\n        lineno = lineno + 1\n        tLine = line[3..-1]\n        if tLine != nil\n          re = /\\s/\n          if line[0..1] == \"- \"\n            ctask = re.match(tLine)\n          else \n            ctask = re.match(line)\n          end\n          if (ctask.pre_match == context) and ((line[0..2] == \"-  \") or (line[0..2] == \"!  \"))\n            results = (fileName[0..-5] + \":\" + lineno.to_s + \": \" + ctask.post_match)\n            matches += 1\n            if matches == 1\n              todoList += \"\\n\" + tag[:label] + \"\\n\" \n            end\n            todoList += results\n          end        \n        end\n      end\n    end\n  end\n  if matches == 0\n    # todoList += \"none\\n\"\n  end\n  todoList += \"\\n\"\nend\n   \nFile.open($myPath + \"/todoList.txt\", \"w\") {|f|\n  f << todoList}\n\nputs \"GeekTool Updated.\"\n",
  input: "none",
  keyEquivalent: "^G",
  name: "Export to GeekTool",
  output: "showAsTooltip",
  scope: "text.html.markdown.wiki.gtd",
  uuid: "4BAA7812-3BED-4A7B-8292-08C17C935BD7"},
 {beforeRunningCommand: "saveActiveFile",
  command: 
   "#!/usr/bin/env ruby  \n\nrequire \"\#{ENV['TM_SUPPORT_PATH']}/lib/textmate\"\nrequire \"erb\"\nrequire \"pp\"\ninclude ERB::Util\nrequire \"\#{ENV['TM_BUNDLE_SUPPORT']}/gtd_functions\" \n\ndisplayAllTasks",
  input: "none",
  keyEquivalent: "^@T",
  name: "GTD List View",
  output: "showAsHTML",
  scope: "text.html.markdown.wiki.gtd",
  uuid: "4351CBE0-CE02-472E-A0A9-F9F895B2946C"},
 {beforeRunningCommand: "nop",
  command: 
   ". \"$TM_SUPPORT_PATH/lib/webpreview.sh\"\nhtml_header \"GTD Bundle Help\" \"Getting Things Done\"\nMarkdown.pl <<\"EOF\"|SmartyPants.pl\n\nThis bundle is shamelessly taken from the TODO bundle and reconfigured for GTD. [More information](http://www.davidco.com) on GTD.\n\n# Setting up the GTD Bundle\n\nThe latest version of the GTD bundle can always be found at [textmate repository]. Additionally, you'll need two files, a contexts file and an exclusions file. These files need to go into a folder where you plan to place all of your .gtd files. I keep mine in `~/Documents/ToDo`.\n\nBasically, the `contexts.gtd` file is a list of contexts, as described above. There are several data elements for each file, a couple of which I no longer use, but keep so that I don't break the system. The big things to get right are the context (first cell), the shortcut key (second cell) and the context string (third element).\n\nThe `exclusions.gtd` file is a list of gtd files that you *don't* want to see listed in the rollup of tasks. Why? Well, it allows me to create project files that I can hide until I want to deal with them. For example, I created a `bookshelf.gtd` file that lists all of the tasks associated with building shelves in my garage. However, I'm not ready for that project yet, so I hide it from my rollup. I've tried to make the GTD bundle as customizable as possible, so while you must have the `excluded.gtd` file, you are free to not use it.\n\n# Using the GTD Bundle\n\nNow that you have downloaded the bundle and the supporting files, you are ready to jump in! First, create a new project file in your ToDo folder (or whatever you call it). Then begin adding tasks by entering a shortcut and hitting the \"**Enter**\" key - not \"Return.\" This should replace the shortcut with the corresponding context string from `contexts.gtd`. Then tab to the data field(s) for that task and hit return to finish entering the task.\n\nContexts are great, but there is also a status component of the gtd list in the GTD bundle. The normal status is how the task is created. The two modified statuses are \"WAIT\" and \"DONE.\" To change the status of a task to \"WAIT\" type \"w\" and then the tab key anywhere on the tasks line (just make sure it is either the first character or there is a pace in from of the \"w\"). Then, when you want to \"unwait\" the task, do the same thing with \"u\". When a task is done, mark it as \"DONE\" using \"d\" and the tab key.\n\nLike I said in the beginning, my objective is to plan in project, execute in context. So, I have a couple of list views, \"Active GTD List View\" and \"GTD List View\". The major difference between the two is that the active list does not show completed tasks, although it does show \"WAIT\" tasks. Either way, the bundle creates a nice looking list of tasks, arranged by context.\n\nOne other subject area is additional list formatting. You can sort all of the tasks in a project by context by pressing `F5`. I personally don't like this, because my projects are generally built in a rough sequence. I have to look up a phone number before I can call it, for example. So, the feature is there, but I don't really use it. There are also a couple of cleanup commands. Cleanup (CTRL-Shift-C) moves all of the \"DONE\" tasks to the bottom of a project list. Remove (CTRL-ALT-Shift-C) does what it says; it removes completed tasks.\n\nEOF\nhtml_footer\n",
  input: "none",
  name: "Help",
  output: "showAsHTML",
  scope: "text.html.markdown.wiki.gtd",
  uuid: "A6C302D1-4EB0-4CE8-AB43-F21672BFFB68"},
 {beforeRunningCommand: "nop",
  command: 
   "#!/usr/bin/env python\nimport sys, os\n\noldtask = os.environ['TM_CURRENT_LINE']\nsys.stdout.write(\"!  \" + oldtask[3:])\n",
  fallbackInput: "line",
  input: "selection",
  name: "Priority",
  output: "replaceSelectedText",
  scope: "text.html.markdown.wiki.gtd",
  tabTrigger: "p",
  uuid: "4BAAE940-7F72-4184-B165-F028FB6E99FF"},
 {beforeRunningCommand: "saveActiveFile",
  command: 
   "#!/usr/bin/env ruby\n\nmyFile = ENV['TM_SELECTED_FILE']\n\nmyText = File.open(myFile)\nre = /\\s/\nmyText.each do |line|\n  myTest = re.match(line)\n  if (myTest.pre_match != \"+\" and myTest.pre_match.length > 0)\n    puts line\n  end\nend  \n",
  input: "document",
  keyEquivalent: "^~C",
  name: "Remove Completed Tasks",
  output: "replaceDocument",
  scope: "text.html.markdown.wiki.gtd",
  uuid: "D1E96B26-25A1-4525-873C-417598FB8814"},
 {beforeRunningCommand: "nop",
  command: 
   "#!/usr/bin/env python\nimport sys, os\n\noldtask = os.environ['TM_CURRENT_LINE']\nif (oldtask[0] != \"+\") and (oldtask[0] != \"^\"):\n\tsys.stdout.write(\"-  \" + oldtask[3:])\nelse:\n    sys.stdout.write(oldtask)",
  fallbackInput: "line",
  input: "selection",
  name: "Undo State Change",
  output: "replaceSelectedText",
  scope: "text.html.markdown.wiki.gtd",
  tabTrigger: "u",
  uuid: "900C7391-7C63-4D1C-AF83-9F3E497F6A7F"},
 {beforeRunningCommand: "nop",
  command: 
   "#!/usr/bin/env python\nimport sys, os\n\noldtask = os.environ['TM_CURRENT_LINE']\nif (oldtask[0] != \"+\") and (oldtask[0] != \"^\"):\n\tsys.stdout.write(\"<- \" + oldtask[3:])\nelse:\n    sys.stdout.write(oldtask)",
  fallbackInput: "line",
  input: "selection",
  name: "Wait",
  output: "replaceSelectedText",
  scope: "text.html.markdown.wiki.gtd",
  tabTrigger: "w",
  uuid: "4C31BAAA-2182-47D7-8B10-2B17A6078FCA"}]
