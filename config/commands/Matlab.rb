# Encoding: UTF-8

[{beforeRunningCommand: "nop",
  command: 
   "#!/usr/bin/env ruby\n# Replace != with ~= for the novice user\nline = ENV['TM_LINE_NUMBER'].to_i\ncolumns = ENV['TM_LINE_INDEX'].to_i-1\ntextArray = STDIN.readlines\nprint textArray.last. to_s.sub(/\\!/,'~=')\n",
  fallbackInput: "line",
  input: "selection",
  keyEquivalent: "=",
  name: "= after !",
  output: "insertAsSnippet",
  scope: "variable.other.exclamation.matlab",
  uuid: "563CDF89-C286-4CDB-94AB-30819104470F"},
 {beforeRunningCommand: "nop",
  command: 
   "#!/usr/bin/env ruby\n\nif ENV.has_key?('TM_SELECTED_TEXT') then\n\tresult = ENV['TM_SELECTED_TEXT'].strip\n\tcase result\n\twhen /'.*'/\n\t\t@pad = \"' '\"\n\telse\n\t\t@pad = \"0\"\n\tend\n\t@input_table = result.to_a.collect {|row| row.chomp.split(/\\s+|,/)}\n\trows = @input_table.length\n\tcolumns = @input_table.inject { |memo, row| memo.length > row.length ? memo : row }.length\nelse\n\tresult=`\"$TM_SUPPORT_PATH/bin\"/CocoaDialog.app/Contents/MacOS/CocoaDialog standard-inputbox \\\n\t--title 'Matlab Array Creation' \\\n\t--informative-text 'Number of rows and columns:' \\\n\t--text '6 4'`.split\n\texit if result[0] == \"2\" || result.length == 1\n\t@input_table = nil\n\tresult.collect! { |num| num.to_i}\n\tresult[2] = result[1] if result.length == 2\n\t# We'll only create up to two-dimensional arrays\n\t# with up to N elements\n\tN = 200\n\tproduct = result[1..2].inject(1) {|product, num| product * num }\n\tif product.zero?\n\t\t# give error message\n\t\texit\n\telsif product > N\n\t\topen('|\"$DIALOG\" tooltip', 'w') do |io|\n\t\t\tio << \"The matrix dimensions are too large.\\nThe maximum is set to \#{N} elements.\"\n\t\tend\n\t\texit\n\telse\n\t\trows, columns = result[1..2]\n\tend\nend\n\n@pos = 0\ndef self.insert(row,column)\n\tif @input_table.nil?\n\t\t@pos += 1\n\t\t\"${\#{@pos}:\#{@pos}}\"\n\telse\n\t\tret = @input_table[row][column]\n\t\tif ret.nil?\n\t\t\t@pos += 1\n\t\t\t\"${\#{@pos}:\#{@pad}}\"\n\t\telse\n\t\t\tret\n\t\tend\n\tend\nend\n\ntable = \"\"\ntable += \"[\" if rows > 1\nrows.times do |m|\n\ttable += \"[\"\n\tcolumns.times do |n|\n\t\ttable += insert(m,n)\n\t\ttable += (n == columns-1) ? \"]\" : \"\\t\"\n\tend\n\ttable += \";\\n\" unless (m == rows-1)\nend\ntable += \"]\" if rows > 1\ntable += \"${\#{@pos+1}:;}\\n$0\"\nputs table\n",
  fallbackInput: "none",
  input: "selection",
  keyEquivalent: "^@T",
  name: "Create matrix",
  output: "insertAsSnippet",
  scope: "source.matlab, source.octave",
  uuid: "F23DAE9B-A27A-41D3-B57B-DED30729243C"},
 {beforeRunningCommand: "nop",
  command: 
   "#!/usr/bin/env ruby\n\ntextarray = STDIN.readlines\ncurrentline = ENV['TM_LINE_NUMBER'].to_i\nnumlines = textarray.size.to_i\nlineindex = ENV['TM_LINE_INDEX'].to_i\nthisline = ENV['TM_CURRENT_LINE']\ncolumns = ENV['TM_LINE_INDEX'].to_i\n\n\nif (textarray.size == currentline) && (textarray.last.length == lineindex)\n    # We're at the very end.\n    if thisline.slice(0...lineindex).slice(/(\\)|\\])$/)\n        # We're outside closed brackets/parens. Just insert an enter\n        print \"\\n\"\n    else\n        print \" ...\\n\"\n    end\nelse\n    # Let's add some dots. If we already have a dot or two, we won't print all three dots\n    dots = thisline.slice(0...lineindex).slice(/\\.+$/).to_s.length\n    case dots\n    when 0\n        print \" ...\"\n    when 1\n        print \"..\"\n    when 2\n        print \".\"\n    end\n    print \"\\n\"\nend\n",
  fallbackInput: "scope",
  input: "document",
  keyEquivalent: "\n",
  name: "Enter in Brackets or Parens Scope",
  output: "insertAsSnippet",
  scope: 
   "(meta.brackets.matlab|meta.brackets.octave) - string.quoted.single.matlab,(meta.parens.matlab|meta.parens.octave) - string.quoted.single.matlab,(meta.brackets.curly.matlab|meta.brackets.curly.octave) - string.quoted.single.matlab",
  uuid: "8A857EDA-B07B-4304-BA10-29C3D22A3B1B"},
 {beforeRunningCommand: "nop",
  command: 
   "#!/usr/bin/env ruby\nthisline = ENV['TM_CURRENT_LINE']\nsoft_tabs = ENV['TM_SOFT_TABS']\ntab_size = ENV['TM_TAB_SIZE'].to_i\n# thisline = \"asdfasd f\t\t\t\t% asdfasdfadsfasd\"\n# thisline = \"aasdfasd ff\t\t\t\t% asdfasdfadsfasd\"\n# thisline = \"aasdfasd fff\t\t\t\t% asdfasdfadsfasd\"\nspaces = thisline.match(/^(.*?)(%%|%|#)(\\s*).*$/)\n\nleading_spaces = spaces.captures[0].gsub(/[^\\t]{4}/,\"\\t\").gsub(/[^\\t]{1,3}\\t/,\"\\t\")\n\nif spaces.captures[0] =~ /\\S/\n\tleading_spaces.gsub!(/\\t/,\"\".ljust(tab_size)) if ENV['TM_SOFT_TABS'] == \"YES\"\nelse\n\tleading_spaces = \"\"\nend\n\nprint \"\\n\#{leading_spaces}\#{spaces.captures[1] + spaces.captures[2]}$1\"\n",
  input: "none",
  keyEquivalent: "",
  name: "Enter in Comment",
  output: "insertAsSnippet",
  scope: 
   "comment.line.percentage.matlab, comment.double.percentage.matlab, comment.line.percentage.octave, comment.double.percentage.octave, comment.line.pound.octave",
  uuid: "615CF7DB-FDB1-4013-9725-FDF4BE64E8A4"},
 {beforeRunningCommand: "nop",
  command: 
   "#!/usr/bin/env ruby\nlineindex = ENV['TM_LINE_INDEX'].to_i\nthisline = ENV['TM_CURRENT_LINE']\nscopes = ENV['TM_SCOPE'].split\n\nfirsthalf = thisline.slice(0...lineindex)\nsecondhalf = thisline.slice(lineindex..-1)\n\nif scopes[0] == \"source.matlab\"\n\tfirsthalf.sub!(/\\s*\\.*\\s*$/,\" ...\")\nelsif scopes[0] == \"source.octave\"\n\tfirsthalf.sub!(/\\s*(\\.*|\\\\)\\s*$/,\" ...\")\nend\nfirsthalf += \"\\n\"\nprint firsthalf, '$1', secondhalf\n\n",
  fallbackInput: "line",
  input: "selection",
  keyEquivalent: "\n",
  name: "Enter in Incomplete Variable Assignment",
  output: "insertAsSnippet",
  scope: 
   "source.matlab invalid.illegal.incomplete-variable-assignment.matlab, source.octave invalid.illegal.incomplete-variable-assignment.matlab",
  uuid: "FD9512A7-561A-4140-A425-567B8D2862EA"},
 {beforeRunningCommand: "nop",
  command: 
   "#!/usr/bin/env ruby\n\n# Due to many special cases, this is rather ugly.\n\n# Set up all parameters\ndebug = false\ntextarray = STDIN.readlines\nlinenumber = ENV['TM_LINE_NUMBER'].to_i\nnumlines = textarray.size\n# Adjust for missing empty last line if last character is a newline\nnumlines += 1 if textarray.last[-1] == 10\nlineindex = ENV['TM_LINE_INDEX'].to_i\nscopes = ENV['TM_SCOPE'].split\npreceding_string = scopes.index(\"punctuation.definition.string.begin.matlab\")\nescaped_quote = scopes.index(\"constant.character.escape.matlab\")\nif debug\n    print \"preceding_string\", \"\\t\\t= ___\", preceding_string, \"___\\n\"\n    print \"escaped_quote\", \"\\t\\t= ___\", escaped_quote, \"___\\n\"\nend\n\nthisline = ENV['TM_CURRENT_LINE']\nfirsthalf = thisline.slice(0...lineindex).gsub(/\\$/,\"\\\\\\$\")\nsecondhalf = thisline.slice(lineindex...thisline.length).gsub(/\\$/,\"\\\\\\$\")\n\natEOL = (thisline.length == lineindex)\natEOF = (atEOL && numlines == linenumber)\nfirstmatch = firsthalf.match(/(')(('{2}|[^'])*)(')?$/)\nsecondmatch = secondhalf.match(/(')?(('{2}|[^'])*)(')?/)\n\nif atEOF\n    if firstmatch.nil?\n        puts \"we have no quotes on this line\" if debug\n        # insert closing quote on preceding line and an enter\n    elsif firstmatch.captures.last == \"'\"\n        puts \"we have a closing quote. insert enter\" if debug\n        firsthalf += \"\\n\"\n    else\n        puts \"we must close the string and insert an enter\" if debug\n        firsthalf += \"'\\n\"\n    end\nelse\n    if preceding_string\n        puts \"we're preceding a string. insert dots and an enter\" if debug\n        # check for =-+/*\n        firsthalf += \" ...\" unless firsthalf.match(/[\\=\\+\\-\\*\\/]\\s*$/).nil?\n        firsthalf += \"\\n\"\n    elsif atEOL\n        puts \"we're at the end of the line. insert a quote and an enter\" if debug\n        firsthalf += \"'\" if secondmatch.captures.first.nil? && secondmatch.captures.last.nil? && firstmatch.captures.last.nil?\n        firsthalf += \"\\n\"\n    else\n        # check if firsthalf is a closed string\n        firsthalf.insert(firstmatch.begin(0),\"[\")\n        if firstmatch.captures.last == \"'\"\n            puts \"first half is a closed string. insert brackets and dots\" if debug\n        else\n            puts \"first half is not closed. insert brackets, closing quote, and dots\" if debug\n            firsthalf += \"'\"\n        end\n        firsthalf += \" ...\\n\"\n        \n        if secondmatch.captures.first.nil?\n            puts \"second half has no opening quote. insert leading quote and closing bracket\" if debug\n            secondhalf = \"'\" + secondhalf\n        end\n        if secondmatch.captures.last.nil?\n            puts \"second half has no closing quote. insert ending quote\" if debug\n            secondhalf += \"']\"\n        else\n            puts \"second half has no closing bracket. insert ending bracket\" if debug\n            bias = secondmatch.captures.first.nil? ? 1 : 0 # compensate index for added quote\n            secondhalf.insert(secondmatch.end(0) + bias,\"]\")\n        end\n    end\nend\n\nif debug\n    print \"linenumber\", \"\\t= ___\", linenumber, \"___\\n\"\n    print \"numlines\", \"\\t= ___\", numlines, \"___\\n\"\n    print \"lineindex\", \"\\t= ___\", lineindex, \"___\\n\"\n    print \"firsthalf\", \"\\t= ___\", firsthalf, \"___\\n\"\n    print \"secondhalf\", \"\\t= ___\", secondhalf, \"___\\n\"\n    print \"scopes\", \"\\t\\t= ___\", scopes, \"___\\n\"\n    print \"preceding_string\", \"\\t\\t= ___\", preceding_string, \"___\\n\"\n    print \"escaped_quote\", \"\\t\\t= ___\", escaped_quote, \"___\\n\"\n    print \"atEOL\", \"\\t\\t= ___\", atEOL, \"___\\n\"\n    print \"atEOF\", \"\\t\\t= ___\", atEOF, \"___\\n\"\n    print \"debug\", \"\\t\\t= ___\", debug, \"___\\n\"\n    print \"firstmatch\", \"\\t= ___\", firstmatch, \"___\\n\"\n    print \"firstmatch.begin(0)\", \"\\t= ___\", firstmatch.begin(0), \"___\\n\"\n    print \"secondmatch\", \"\\t= ___\", secondmatch, \"___\\n\"\n    print \"secondmatch.end(3)\", \"\\t= ___\", firstmatch.begin(3), \"___\\n\"\n    print \"firstmatch.captures\\t\\t\", firstmatch.captures.inspect, \"\\n\"\n    print \"secondmatch.captures\\t\", secondmatch.captures.inspect, \"\\n\"\nend\n\nprint firsthalf, '$1', secondhalf\n",
  fallbackInput: "line",
  input: "selection",
  keyEquivalent: "\n",
  name: "Enter in String",
  output: "insertAsSnippet",
  scope: 
   "string.quoted.single.matlab - meta.brackets.matlab, string.quoted.single.matlab - meta.parens.matlab",
  uuid: "12A5489D-0A50-4420-A53D-FB0C6A2794CD"},
 {beforeRunningCommand: "nop",
  command: 
   "#!/usr/bin/env ruby\n\ntextarray = STDIN.readlines\ncurrentline = ENV['TM_LINE_NUMBER'].to_i\nnumlines = textarray.size.to_i\nlineindex = ENV['TM_LINE_INDEX'].to_i\nthisline = ENV['TM_CURRENT_LINE']\ncolumns = ENV['TM_LINE_INDEX'].to_i\nif columns == 0 && thisline[0] == ?'\n    print \"...\\n\"\nelse\n    if thisline.slice(0...lineindex).slice(/\\'+$/).to_s.length.modulo(2) == 0\n        # We must insert a quote\n        print \"'\"\n    end\n    if (textarray.size == currentline) && (textarray.last.length == lineindex)\n        # We're at the very end. If the last character is a quotation mark\n        # we'll not add a leading quote.\n        print \" ...\\n'$1']\"\n    else\n        print \" ...\\n'\"\n    end\nend",
  input: "document",
  keyEquivalent: "\n",
  name: "Enter in String in Brackets Scope",
  output: "insertAsSnippet",
  scope: "meta.brackets.matlab string.quoted.single.matlab",
  uuid: "732F1DA4-166B-44AF-88CD-5A944574D3CC"},
 {beforeRunningCommand: "nop",
  command: 
   "if grep <<<${TM_CURRENT_WORD:-!} -Esq '[a-zA-Z0-9_]+'\n\tthen exit_show_html \"<meta http-equiv='Refresh' content='0;URL=http://www.mathworks.com/access/helpdesk/help/techdoc/index.html?/access/helpdesk/help/techdoc/ref/${TM_CURRENT_WORD}.html'>\"\n\telse echo \"Nothing to lookup (hint: place the caret on a function name)\"\nfi\n",
  fallbackInput: "word",
  input: "selection",
  keyEquivalent: "^h",
  name: "Function Documentation",
  output: "showAsHTML",
  scope: "source.matlab",
  uuid: "033730AF-96F5-4F0C-9199-E0683D40A22C"},
 {beforeRunningCommand: "nop",
  command: 
   "#!/usr/bin/env ruby\n\nwidth = 80\n\ntopbottom = \"%%\".ljust(width,\"=\") + \"\\n\"\n\nprint topbottom\nprint \"%%${1/^\" + \"(.)?\"*(width-2) + \".*$/\"\n1.upto(width-2) { |i| print \"(?\#{i}:: )\" }\nprint \"/}${1:Header}\" + \"\\n\"\nprint topbottom\n",
  input: "none",
  name: "Insert header comment",
  output: "insertAsSnippet",
  scope: "source.matlab, source.octave",
  tabTrigger: "head",
  uuid: "AD7201FB-23AD-4105-B8E3-5AAD29419FA6"},
 {beforeRunningCommand: "nop",
  command: 
   "#!/usr/bin/env ruby\n\nwidth = 80\nbuffer = 5\n\nprint \"%%${1/^\" + \"(.)?\"*(width) + \".*$/\"\n1.upto(width-2-buffer) { |i| print \"(?\#{i}::=)\" }\nprint \"/}\".ljust(buffer+2)\nprint \"${1:Header}\" + \"\\n$0\"\n",
  input: "none",
  name: "Insert section division",
  output: "insertAsSnippet",
  scope: "source.matlab, source.octave",
  tabTrigger: "div",
  uuid: "D21BACE2-24A1-43EF-854C-460F5A55694E"},
 {beforeRunningCommand: "nop",
  command: 
   "#!/usr/bin/env python\n\nimport sys,os\nsys.path.append(os.environ['TM_SUPPORT_PATH'] + '/lib')\n\nimport dialog\n\nline_no = int(os.environ.get('TM_LINE_NUMBER'))-1\nlines = sys.stdin.readlines()\n\ntry: \n    sel = os.environ['TM_SELECTED_TEXT']\nexcept KeyError:\n    pass\nelse:\n    try:\n        var = dialog.get_string(text='Enter new variable name', \n        prompt='Variable name:')\n    except AttributeError:\n        print '% Please update your support directory'\n        var = 'var'\n\n    term = os.environ.get('TM_LINE_TERMINATOR') or ';'\n    lines[line_no] = lines[line_no].replace(sel, var)\n    lines.insert(line_no, '%s = %s%s\\n' % (var, sel, term))\n\nfor line in lines:\n\tprint line,",
  input: "document",
  keyEquivalent: "^C",
  name: "Introduce variable (line)",
  output: "replaceDocument",
  scope: "source.matlab,source.python",
  uuid: "40B52D65-1B7C-4874-AA30-B4C95089CE55"},
 {beforeRunningCommand: "nop",
  command: 
   "#!/usr/bin/env python\n\nimport sys,os\nsys.path.append(os.environ['TM_SUPPORT_PATH'] + '/lib')\n\nimport dialog\n\ndef first_occurance(arr, str):\n    \"\"\"find first_occurance of str in an array of strings\"\"\"\n    line_no = 0\n    # Find first instance of `sel`\n    for line in lines:\n        try:\n            line.index(sel)\n            line_no = lines.index(line)\n            break\n        except ValueError:\n            pass\n    \n    return line_no\n\nlines = sys.stdin.readlines()\nsel = ''\nvar = ''\n\ntry: \n    sel = os.environ['TM_SELECTED_TEXT']\nexcept KeyError:\n    pass\nelse:\n    line_no = first_occurance(lines, sel)-1\n    try:\n        var = dialog.get_string(text='Enter new variable name', \n        prompt='Variable name:')\n    except AttributeError:\n        print '% Please update your support directory'\n        var = 'var'\n\nfor line in lines[0:line_no]:\n\tprint line.replace(sel, var),\n\nterm = os.environ.get('TM_LINE_TERMINATOR') or ';'\nprint '%s = %s%s\\n' % (var, sel, term),\n\nfor line in lines[line_no:]:\n\tprint line.replace(sel, var),\n\n",
  input: "document",
  keyEquivalent: "^C",
  name: "Introduce variable (throughout)",
  output: "replaceDocument",
  scope: "source.matlab,source.python",
  uuid: "4B350792-24A2-4083-A8FB-509DF4BD709A"},
 {beforeRunningCommand: "nop",
  command: 
   "f=`find . \"$HOME/matlab\" /Applications/MATLAB* -name \"${TM_SELECTED_TEXT:-$TM_CURRENT_WORD}.m\"|head -1`\n\nif [[ -e \"$f\" ]]\n  then open -a TextMate \"$f\"\n  else echo \"File could not be found.\"\nfi\n",
  input: "none",
  keyEquivalent: "@O",
  name: "Open Function",
  output: "showAsTooltip",
  scope: "source.matlab",
  uuid: "D7A8ED42-49E0-4CF3-A6C8-BE8DAB76267A"},
 {beforeRunningCommand: "nop",
  command: 
   "#!/usr/bin/env ruby\n\ninput = STDIN.readlines\n\ninput.each do |str|\n  puts case str\n  when /\\A(.*?)#+\\s*(.*)$/: $1 + ENV['TM_COMMENT_START'] + $2  \n  when /\\A(.*?)%+\\s*(.*)$/: $1 + ENV['TM_COMMENT_START'] + $2  \n  # Default case\n  else str\n  end\nend\n",
  fallbackInput: "line",
  input: "document",
  keyEquivalent: "^@C",
  name: "Replace comments with default",
  output: "replaceDocument",
  scope: "source.matlab, source.octave",
  uuid: "321567FE-2E57-4D5C-BEFB-98FE869FF4D7"},
 {beforeRunningCommand: "nop",
  command: 
   "#!/usr/bin/env ruby\n\nprint case str = STDIN.read\n  when /\\A(.*?)\\%(.*)$/: $1 + '#' + $2  \n  when /\\A(.*?)#(.*)$/: $1 + '%' + $2\n  # Default case\n  else str\nend\n",
  fallbackInput: "line",
  input: "selection",
  keyEquivalent: "@C",
  name: "Toggle comment style",
  output: "replaceSelectedText",
  scope: "source.matlab, source.octave",
  uuid: "BEAE3101-B710-4BDE-A178-247F9FB6C018"},
 {beforeRunningCommand: "nop",
  command: 
   "#!/usr/bin/env ruby\nrequire ENV[\"TM_BUNDLE_SUPPORT\"] + \"/lib/MATLABUtils.rb\"\ninclude MATLAB\nvariables = MATLAB.get_variables\nputs \"clear('${1:\#{variables.join(\"','\")}}'$2);\"\n",
  input: "document",
  name: "clear",
  output: "insertAsSnippet",
  scope: "source.matlab, source.octave",
  tabTrigger: "cl",
  uuid: "31D0DE27-0382-4F5F-B005-351F9D9B4589"},
 {beforeRunningCommand: "nop",
  command: 
   "#!/usr/bin/env ruby\n# Wrap the current word or selected text in num2str()\n# or insert \" if there is no word\n\nseltext = ENV['TM_SELECTED_TEXT'].to_s \ncurword = ENV['TM_CURRENT_WORD'].to_s\n\nif !seltext.empty?\n\tprint \"num2str(\", seltext, \")\"\nelsif  !curword.empty?\n\tprint \"num2str(\", curword, \")\"\nelse\n    print \"\\\"\"\nend",
  fallbackInput: "word",
  input: "selection",
  keyEquivalent: "^'",
  name: "num2str",
  output: "insertAsSnippet",
  scope: 
   "(source.matlab|source.octave) - (string.quoted.single.matlab | comment.line.percentage.matlab | comment.double.percentage.matlab)",
  uuid: "6F519B71-2D99-455B-9E4A-F614FD9CA253"},
 {beforeRunningCommand: "nop",
  command: 
   "#!/usr/bin/env ruby\nrequire ENV[\"TM_BUNDLE_SUPPORT\"] + \"/lib/MATLABUtils.rb\"\ninclude MATLAB\nvariables = MATLAB.get_variables\nputs \"save(${1:'${2:filename}'},${3:'${4:\#{variables.join(\"','\")}}'}$5);\"\n",
  input: "document",
  name: "save",
  output: "insertAsSnippet",
  scope: "source.matlab, source.octave",
  tabTrigger: "save",
  uuid: "EA2AB0C2-A215-4503-930C-785CDF66F95B"},
 {beforeRunningCommand: "nop",
  command: 
   "#!/usr/bin/env ruby\n#\n# Looks through code, finds the last subplot function\n# and pre-populates the new subplot call with values\n# from last function. If the input values are numeric,\n# we increment the last argument.\n#\nlinesbefore = ENV['TM_LINE_NUMBER'].to_i-1\ncolumns = ENV['TM_LINE_INDEX'].to_i\ntextArray = STDIN.readlines\nmyStr = textArray[0...linesbefore].join\nmyStr << textArray[linesbefore].to_s.slice(0...columns)\n\nif myStr =~ /.*(subplot\\()(\\w+[*]?)(\\,)(\\w+[*]?)(\\,)(\\w+[*]?)(\\))/m\n  subrows, subcols, subthis = $2, $4, $6\n\n  # We have a pure number\n  subthis = subthis.to_i + 1 if subthis =~ /\\A\\d+\\z/\nelse\n  subrows = \"rows\"\n  subcols = \"cols\"\n  subthis = \"current\"\nend\n\nprint \"subplot(${1:\", subrows, \"},\"\nprint \"${2:\", subcols, \"},\"\nprint \"${3:\", subthis, \"})${4:, }$0\"",
  fallbackInput: "document",
  input: "document",
  name: "subplot",
  output: "insertAsSnippet",
  scope: "source.matlab, source.octave",
  tabTrigger: "sub",
  uuid: "F674E1B2-5BA5-4397-9D54-D48623E9F2FD"}]
