# Encoding: UTF-8

[{beforeRunningCommand: "nop",
  command: "ocamldoc -html -d /tmp \"$TM_FILENAME\"\nopen /tmp/index.html",
  input: "none",
  keyEquivalent: "^~@d",
  name: "Build Ocamldoc",
  output: "showAsTooltip",
  scope: "source.ocaml",
  uuid: "7E096535-0E9E-4866-956A-CCE8694F85A8"},
 {beforeRunningCommand: "nop",
  command: 
   "#!/usr/bin/env ruby\n\n# Converts function signatures into function defs\n# val of_gtk : ?cols:cols \n#   -> ?expand:expand\n#   -> ?fill:bool \n#   -> GObj.widget \n#   -> unit t\n\nval = $stdin.read\n\nstart_padding = val[/^\\s*/m]\nend_padding = val[/\\s*$/m]\nval.strip!\n\nparts = val.split(/:/)\n\nname = parts[0]\nname.sub!(/^(\\s*)val/, \"\\1let\")\n\nargs = parts[1..-1].join(':').split(/\\s*->\\s*/)\nnext_arg = 'a'\nargs = args.map do |arg|\n  arg.strip!\n  if arg =~ /^\\?.*:/\n    arg[/^(\\?.*?):/, 1]\n  elsif arg =~ /:/\n    \"~\" + arg[/^(.*?):/, 1]\n  elsif arg == \"unit\"\n    \"()\"\n  else\n    arg = next_arg\n    next_arg = next_arg.succ\n    arg\n  end\nend\n\nprint \"\#{start_padding}\#{name.rstrip} \#{args.join(' ')} =\\n\\n;;\#{end_padding}\" \n",
  fallbackInput: "line",
  input: "selection",
  keyEquivalent: "^~@c",
  name: "Convert function signature",
  output: "replaceSelectedText",
  scope: "source.ocaml",
  uuid: "BD73877C-081E-4326-A532-8117047F6B1A"},
 {beforeRunningCommand: "nop",
  command: 
   "echo let ${TM_SELECTED_TEXT:-$TM_CURRENT_WORD} \\${1:args} =\necho -n\t\\$0\n",
  fallbackInput: "word",
  input: "selection",
  keyEquivalent: "$\n",
  name: "New Function",
  output: "insertAsSnippet",
  scope: "source.ocaml",
  uuid: "57BED2F3-62ED-4DDF-B1C5-1395BF8CC2B4"},
 {beforeRunningCommand: "nop",
  command: 
   "cat <<SNIPPET\nmethod ${TM_SELECTED_TEXT:-$TM_CURRENT_WORD} \\${1:args} =\n\t\\$0\nSNIPPET",
  fallbackInput: "word",
  input: "selection",
  keyEquivalent: "$\n",
  name: "New Method",
  output: "insertAsSnippet",
  scope: "source.ocaml meta.object",
  uuid: "AE75286C-FB51-4AD9-A580-9FABEA1E477A"},
 {beforeRunningCommand: "nop",
  bundleUUID: "F80D3822-6EE8-11D9-BF2D-000D93589AF6",
  command: 
   "#!/usr/bin/env ruby\nrequire ENV['TM_SUPPORT_PATH'] + \"/lib/exit_codes\"\nrequire \"\#{ENV['TM_SUPPORT_PATH']}/lib/escape\"\n\nline = STDIN.read\n\ndef candidates_or_exit(methodSearch=\"\")\n  zGrepped = %x{ zgrep ^\#{e_sh methodSearch } \#{e_sh ENV['TM_BUNDLE_SUPPORT']}/OCamlSnippets.txt.gz }\n  candidates = zGrepped.split(\"\\n\")\n  TextMate.exit_show_tool_tip \"No completion available\" if candidates.empty?\n  return candidates\nend\n\ndef prettify(candidate)\n  candidate.gsub(/\\$\\{\\d+:|\\}|\\$0/,\"\")  \nend\n\ndef snippet_generator(cand, start)\n  cand[start..-1]  \nend\n\ndef pop_up(candidates, searchTerm)\n  start = searchTerm.size\n  prettyCandidates = candidates.map { |candidate| [prettify(candidate), candidate] }.sort\n  if prettyCandidates.size > 1\n    require \"enumerator\"\n    pruneList = []  \n\n    prettyCandidates.each_cons(2) do |a| \n      pruneList << (a[0][0] != a[1][0]) # check if prettified versions are the same\n    end\n    pruneList << true\n    ind = -1\n    prettyCandidates = prettyCandidates.select do |a| #remove duplicates\n      pruneList[ind+=1]  \n    end\n  end\n\n  if prettyCandidates.size > 1\n    #index = start\n    #test = false\n    #while !test\n    #  candidates.each_cons(2) do |a,b|\n    #    break if test = (a[index].chr != b[index].chr || a[index].chr == \"\\t\")\n    #  end\n    #  break if test\n    #  searchTerm << candidates[0][index].chr\n    #  index +=1\n    #end\n    require \"\#{ENV['TM_SUPPORT_PATH']}/lib/osx/plist\"\n    dialog_path = \"\#{ENV['TM_SUPPORT_PATH']}/bin/tm_dialog\"\n    pl = {'menuItems' => prettyCandidates.map { |pretty, full | { 'title' => pretty, 'cand' => full} }}\n    plist = pl.to_plist\n    res = OSX::PropertyList::load(%x{ \#{e_sh dialog_path} -up \#{e_sh plist} })\n    if res.has_key? 'selectedMenuItem'\n      snippet_generator( res['selectedMenuItem']['cand'], start )\n    else\n      \"\"\n    end\n  else\n    snippet_generator( candidates[0], start )\n  end\nend\n\ncaret_placement =ENV['TM_LINE_INDEX'].to_i - 1\nbackContext = line[1+caret_placement..-1].match /^[a-zA-Z0-9_]/\n\nif backContext\n  print line[0..caret_placement]+ \"$0\"+ line[caret_placement+1..-1]\n  TextMate.exit_discard\nend\n\n\nalpha_and_caret = /[a-zA-Z_][_a-zA-Z0-9]*\\(?$/\nif k = line[0..caret_placement].match(alpha_and_caret)\n  candidates = candidates_or_exit(k[0])\n  res = pop_up(candidates, k[0])\nelse\n  res = \"\"\nend\nprint line[0..caret_placement] + res + \"$0\"+ line[caret_placement+1..-1]",
  input: "selection",
  keyEquivalent: "^~@",
  name: "OCaml Completion - disabled",
  output: "insertAsSnippet",
  scope: "source.ocaml",
  uuid: "C6EBDA90-DEEF-43B8-BE1C-78759877BA35"},
 {beforeRunningCommand: "nop",
  command: 
   "TO_OCAML=${TM_OCAML:=ocamlc}\nTMPDIR=${TMPDIR:=/tmp}\n\nrequire_cmd \"$TO_OCAML\"\n\n# get a tempfile and fill it with the contents of our file\nSRCFILE=`/usr/bin/mktemp $TMPDIR/ocamlXXXXXX` || exit 1\nmv \"$SRCFILE\" \"$SRCFILE\".ml\n\nDSTFILE=`/usr/bin/mktemp $TMPDIR/ocamlXXXXXX` || exit 1\n\ncat > \"$SRCFILE\".ml\n\n# compile it to a new tempfile\ncd \"$TMPDIR\"\n\n# run it and clean up after ourselves\n\"$TM_BUNDLE_SUPPORT/OCamlMate/run_script.rb\" \"$TO_OCAML\" \"$SRCFILE\".ml \"$DSTFILE\"\n\nrm -f \"$SRCFILE\".*\nrm -f \"$DSTFILE\"\n\n",
  fallbackInput: "document",
  input: "selection",
  keyEquivalent: "@r",
  name: "Run",
  output: "showAsHTML",
  scope: "source.ocaml",
  uuid: "86A99A45-C6B6-4F46-BBB5-04351FD5E3B1"},
 {beforeRunningCommand: "nop",
  command: 
   "#!/bin/bash\n\n\"$TM_BUNDLE_SUPPORT\"/annot -type $TM_LINE_NUMBER $TM_LINE_INDEX ${TM_FILEPATH/%\\.ml/\\.annot}",
  input: "none",
  keyEquivalent: "^t",
  name: "Show Type",
  output: "showAsTooltip",
  scope: "source.ocaml",
  uuid: "50C87892-73B6-4B09-B286-78A50136BC71"},
 {beforeRunningCommand: "nop",
  command: "\"${TM_BUNDLE_SUPPORT}/wrap\"",
  disableOutputAutoIndent: true,
  fallbackInput: "line",
  input: "selection",
  keyEquivalent: "^q",
  name: "Wrap Line",
  output: "replaceSelectedText",
  scope: "source.ocaml",
  uuid: "41481AFE-8B7C-4B7F-AECA-6725DADC0B27"},
 {beforeRunningCommand: "nop",
  command: 
   "#!/usr/bin/env ruby\n\n$: << ENV['TM_SUPPORT_PATH']\nrequire 'lib/escape'\n\ndef make_tab()\n\tsize = ENV['TM_TAB_SIZE'].to_i\n\tif ENV['TM_SOFT_TABS'] == 'YES'\n\t\treturn ' ' * size\n\telse\n\t\treturn \"\\t\"\n\tend\nend\n\n\ntext = ENV['TM_SELECTED_TEXT']\nindent = text[/^\\s*/]\ntab = make_tab()\ntext = text.to_a.map() { |l| tab + l }\n\nputs indent + \"begin\"\nprint e_sn(text.join().chomp() + \"\\n\")\nputs indent + \"end\"",
  fallbackInput: "none",
  input: "selection",
  keyEquivalent: "^W",
  name: "Wrap Section in begin/end",
  output: "insertAsSnippet",
  scope: "source.ocaml",
  uuid: "34B55C0A-C51E-4137-9811-B805640042C8"},
 {beforeRunningCommand: "nop",
  command: 
   "#!/usr/bin/env ruby\n\n$: << ENV['TM_SUPPORT_PATH']\nrequire 'lib/escape'\n\ndef make_tab()\n\tsize = ENV['TM_TAB_SIZE'].to_i\n\tif ENV['TM_SOFT_TABS'] == 'YES'\n\t\treturn ' ' * size\n\telse\n\t\treturn \"\\t\"\n\tend\nend\n\n\ntext = ENV['TM_SELECTED_TEXT']\nindent = text[/^\\s*/]\ntab = make_tab()\ntext = text.to_a.map() { |l| tab + l }\n\nputs indent + \"try\"\nprint e_sn(text.join().chomp() + \"\\n\")\nputs indent + \"with\"\nputs indent + \"| ${1:err} -> ${2:raise err}\"\nprint \"$0\"",
  fallbackInput: "none",
  input: "selection",
  keyEquivalent: "^~W",
  name: "Wrap Section in try/with",
  output: "insertAsSnippet",
  scope: "source.ocaml",
  uuid: "7DC24224-9222-4ACF-9F70-BBF12BF965E4"}]
