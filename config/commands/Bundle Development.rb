# Encoding: UTF-8

[{beforeRunningCommand: "nop",
  command: "tr <<< \"$TM_SCOPE\" ' ' '\\n'|pbcopy",
  input: "none",
  keyEquivalent: "^@C",
  name: "Copy Scope",
  output: "discard",
  uuid: "F9CD7A8F-9EE9-483B-86BE-12D576AFC036"},
 {beforeRunningCommand: "nop",
  bundleUUID: "3CC1A984-EF93-4011-ADDC-FE2E10C6FB23",
  command: 
   "#!/usr/bin/env ruby\n#\n#  regexp_to_list.rb\n#  Created by Hans-Jörg Bibiko on 2008-09-22.\n#\n#  Read a optimized regexp from stdin and output a list of all matched keywords\n#\n\ndef decompileRe (reStr)\n  # handle foo(bar|boo|bou)? => foo|foobar|fooboo|foobou\n  re = Regexp.new(/\\b(\\w+)\\(([^(]+?)\\)\\?/)\n  while m = reStr.match(re) do\n    reStr.sub!(re, \"\#{m[1]}|\#{m[2].split('|').map {|x| m[1] + x }.join('|')}\")\n  end\n  # handle foo(bar|boo|bou) => foobar|fooboo|foobou recursively\n  re = Regexp.new(/\\b(\\w+)\\(([^(]+?)\\)/)\n  while m = reStr.match(re)  do\n    reStr.sub!(re, \"\#{m[2].split('|').map {|x| m[1] + x }.join('|')}\")\n  end\n  # return sorted array and delete last () if there're\n  return reStr.split('|').map {|x| x.gsub(/(\\(|\\))/,'')}.sort\nend\n\n\ndecompileRe(STDIN.read.chomp).each {|r| puts r}",
  fallbackInput: "none",
  input: "selection",
  name: "Deoptimize Regex Alternations",
  output: "openAsNewDocument",
  uuid: "857CF8FA-C613-4D48-9739-58EE774D639E"},
 {beforeRunningCommand: "nop",
  command: 
   "echo \"<html><head><meta http-equiv=\\\"Refresh\\\" content=\\\"0; http://www.macromates.com/textmate/manual/language_grammars#naming_conventions\\\"></head><body></body></html>\"",
  input: "none",
  keyEquivalent: "^h",
  name: "Help: Scope Conventions",
  output: "showAsHTML",
  scope: 
   "string.quoted.single.scope.tm-grammar, string.quoted.single.scope.root.tm-grammar, string.quoted.double.scope.tm-grammar, string.quoted.double.scope.root.tm-grammar",
  uuid: "385A50A5-37DB-4B58-A6B0-1849D17A322F"},
 {beforeRunningCommand: "nop",
  command: 
   "#!/usr/bin/env ruby\n\nscope   = STDIN.read\n\n# If we are working on a selection, exit\nif ENV['TM_SELECTED_TEXT'] then\n  if scope =~ /\\A\\d+\\Z/ then\n    print scope\n    exit\n  end\n  print \"\\n\"\n  exit\nend\n\nsnippet = \"\"\nrules   = []\nbefore_caret = 0\n\ntype = scope.match(/((beginC|endC|c)aptures)/)[0]\n# Compute position of the caret.\ncaretpos = ENV['TM_LINE_NUMBER'].to_i() - ENV['TM_INPUT_START_LINE'].to_i() + 1\n\n# Figure out how many rules come before the caret\nscope.sub(/(\n              (.*\\n){\#{caretpos}}     |   # Match normally.\n              (.*\\n)+                 |   # Match for if the caret is on the last line.\n              (.*)                        # Match for scope with no newline.\n           )/x) { |match|\n  match.gsub(/\\d\\s*=/) {|m| before_caret += 1 }\n}\n\n# Add each existing rule to the rules array and clean it up in the process.\nscope.gsub(/(\\d+\\s*=\\s*\\{\\s*name\\s*=.*?\\};)/) { |match|\n  rules << match.gsub(/(\\d+)\\s*=\\s*\\{\\s*name\\s*=\\s*'((?:'(?=')|.)*?)'\\s*\\};/, \"\\1 = { name = '\\2' };\")\n}\n\n# Insert new rule, either in the middle or after other rules depending\n# on previously determined caret position.\nif rules.length >= before_caret\n  rules.insert(before_caret, \"${1:⁋} = { name = '$2'; };$0\")\nelse\n  rules << \"${1:⁋} = { name = '$2'; };$0\"\nend\n\n# Add each rule to the output\nrules.each { |rule|\n  snippet << \"\\t\" + rule + \"\\n\"\n}\n\n# Use the first number that hasn't been used yet as the default.\n1.upto(rules.length) { |capnum|\n  unless snippet =~ /\\b\#{capnum.to_s}\\s*=/ then\n    snippet.gsub!(/⁋/) { |match| capnum.to_s }\n    break\n  end\n}\n\n# Add wrapper {}\nif scope =~ /aptures\\s*=[^\\n]*\\{/ then\n  snippet = \"\#{type} = {\\n\#{snippet}};\"\nelse\n  snippet = \"\#{type} =\\n{\#{snippet}};\"\nend\n\nprint snippet",
  fallbackInput: "scope",
  input: "selection",
  keyEquivalent: "",
  name: "New Captures Rule",
  output: "insertAsSnippet",
  scope: "source.plist.tm-grammar meta.dictionary.captures",
  uuid: "02F6DE2C-3334-4DCE-9FBB-6F8906653E5C"},
 {beforeRunningCommand: "nop",
  command: 
   "#!/usr/bin/env ruby\n#\n#  list_to_regexp.rb\n#  Created by Allan Odgaard on 2005-11-28.\n#\n#  Takes list of matches on successive lines and outputs\n#  a compact regexp which will match any of the elements\n#  in the list\n#\n\ndef process_list (list)\n\n  buckets = { }\n  optional = false\n\n  list.each do |str|\n    if str.empty? then\n      optional = true\n    else\n      ch = str.shift\n      buckets[ch] = (buckets[ch] or []).push(str)\n    end\n  end\n\n  unless buckets.empty? then\n    ptrns = buckets.collect do |key, value|\n      [key].pack('C') + process_list(value).to_s\n    end\n\n    if optional == true then\n      \"(\" + ptrns.join(\"|\") + \")?\"\n    elsif ptrns.length > 1 then\n      \"(\" + ptrns.join(\"|\") + \")\"\n    else\n      ptrns\n    end\n  end\n\nend\n\nprint process_list(STDIN.collect { |line| line.chomp.unpack('C*') })\n",
  input: "selection",
  name: "Optimize Regex Alternations",
  output: "replaceSelectedText",
  uuid: "442B31EC-07A9-45E4-92D1-B083EB088CDB"},
 {beforeRunningCommand: "nop",
  command: 
   "#!/usr/bin/env ruby -wKU\n\nrequire \"\#{ENV['TM_SUPPORT_PATH']}/lib/current_word\"\nrequire \"\#{ENV['TM_SUPPORT_PATH']}/lib/ui\"\nrequire \"\#{ENV['TM_SUPPORT_PATH']}/lib/exit_codes\"\n\npartial_scope = Word.current_word('a-zA-Z._#+-', :left)\nmatches = []\n\n# Only if we are in an empty include rule, otherwise use the main scope completion.\nif ENV['TM_SCOPE'] =~ /string\\.quoted\\.(single|double)\\.include/ && partial_scope == \"\"\n  options = []\n  options << { 'title' => \"Selected Grammar ($base)\", 'string' => \"\\\\$base\" }\n  options << { 'title' => \"This Grammar ($self)\", 'string' => \"\\\\$self\" }\n  options << { 'title' => \"Repository Item\", 'string' => \"\\\#${0:repository_item}\" }\n  options << { 'separator' => 1 }\n  options << { 'title' => \"source\", 'string' => \"source.\" }\n  options << { 'title' => \"text\", 'string' => \"text.\" }\n  res = TextMate::UI.menu(options)\n  print res['string'] if res\n  exit 204\nend\n\nif ENV['TM_SCOPE'] =~ /string\\.quoted\\.(single|double)\\.scope\\.root/\n  $scopes = \"source.\\ntext.html.\\ntext.plain.\\ntext.xml.\"\nelse\n  $scopes = DATA.read\nend\n\n$scopes.each_line do |line|\n  matches << $1 if line =~ /(^\#{Regexp.escape partial_scope}[-a-zA-Z._#+]*?\\.)/\nend\n\nmatches.uniq!\n\noptions = Array.new(matches)\n\nmatches.collect! { |m| m.sub(/\#{Regexp.escape partial_scope}(.*)/, '\\1') }\noptions.collect! { |m| m.sub(/^(.*)\\.$/, '\\1') }\n\nif matches.empty?\n  print \"\"\nelsif matches.length == 1\n  print matches.first\nelsif index = TextMate::UI.menu(options)\n  print matches[index]\nend\n\n__END__\n\ncomment.block.documentation.\ncomment.block.empty.\ncomment.block.preprocessor.\ncomment.line.apostrophe.\ncomment.line.asterisk.\ncomment.line.at-sign.\ncomment.line.backtick.\ncomment.line.double-backslash.\ncomment.line.double-dash.\ncomment.line.double-dash.\ncomment.line.double-dot.\ncomment.line.double-number-sign.\ncomment.line.double-slash.\ncomment.line.exclamation.\ncomment.line.number-sign.\ncomment.line.parentheses.\ncomment.line.percent.\ncomment.line.percentage.\ncomment.line.semicolon.\ncomment.line.slash.\nconstant.character.entity.\nconstant.character.escape.\nconstant.language.boolean.\nconstant.language.null.\nconstant.numeric.base64.\nconstant.numeric.float.\nconstant.numeric.integer.binary.\nconstant.numeric.integer.decimal.\nconstant.numeric.integer.hexadecimal.\nconstant.numeric.integer.long.\nconstant.numeric.integer.octal.\nconstant.other.placeholder.\nconstant.other.reference.\nconstant.other.symbol.\nentity.name.function.\nentity.name.section.\nentity.name.tag.block.\nentity.name.tag.form.\nentity.name.tag.inline.\nentity.name.tag.localname.\nentity.name.tag.meta.\nentity.name.tag.object.\nentity.name.type.class.\nentity.name.type.module.\nentity.other.attribute-name.\nentity.other.inherited-class.\ninvalid.deprecated.obsolete.\ninvalid.deprecated.trailing-whitespace.\ninvalid.illegal.whitespace\nkeyword.control.def.\nkeyword.control.directive.\nkeyword.control.exception.\nkeyword.control.import.\nkeyword.operator.arithmetic.\nkeyword.operator.assignment.\nkeyword.operator.comparison.\nkeyword.operator.logical.\nkeyword.other.directive.\nkeyword.other.documentation.\nmarkup.bold.\nmarkup.deleted.\nmarkup.heading.\nmarkup.italic.\nmarkup.list.numbered.\nmarkup.list.unnumbered.\nmarkup.other.\nmarkup.quote.\nmarkup.raw.block.\nmarkup.raw.inline.\nmarkup.underline.link.\nmeta.array.\nmeta.block.\nmeta.class.\nmeta.definition.\nmeta.directive.\nmeta.element.\nmeta.embedded.block.\nmeta.embedded.expression.\nmeta.embedded.line.\nmeta.expression.\nmeta.function.\nmeta.group.\nmeta.header.\nmeta.link\nmeta.module.\nmeta.paragraph.\nmeta.preprocessor.\nmeta.property.\nmeta.scope.\nmeta.section\nmeta.separator.\nmeta.structure.\nmeta.tag.block.\nmeta.tag.form.\nmeta.tag.inline.\nmeta.tag.meta.\nmeta.tag.object.\nmeta.tag.preprocessor.\nmeta.toc-list.\npunctuation.definition.arguments.begin.\npunctuation.definition.arguments.end.\npunctuation.definition.array.begin.\npunctuation.definition.array.end.\npunctuation.definition.comment.\npunctuation.definition.constant.\npunctuation.definition.entity.\npunctuation.definition.function.\npunctuation.definition.heading.\npunctuation.definition.keyword.\npunctuation.definition.parameters.begin.\npunctuation.definition.parameters.end.\npunctuation.definition.preprocessor.\npunctuation.definition.string.begin.\npunctuation.definition.string.end.\npunctuation.definition.tag.\npunctuation.definition.variable.\npunctuation.section.array.\npunctuation.section.class.\npunctuation.section.embedded.begin.\npunctuation.section.embedded.end.\npunctuation.section.function.\npunctuation.section.group.\npunctuation.section.scope.\npunctuation.separator.arguments.\npunctuation.separator.array.\npunctuation.separator.continuation.\npunctuation.separator.key-value.\npunctuation.separator.parameters.\npunctuation.terminator.expression.\npunctuation.terminator.function.\npunctuation.terminator.rule.\npunctuation.terminator.statement.\npunctuation.whitespace.comment.leading.\npunctuation.whitespace.comment.trailing.\npunctuation.whitespace.embedded.leading.\npunctuation.whitespace.embedded.trailing.\nsource.\nstorage.modifier.extends.\nstorage.modifier.global.\nstorage.modifier.implements.\nstorage.type.class.\nstorage.type.function.\nstorage.type.method.\nstorage.type.module.\nstring.interpolated.\nstring.other.\nstring.quoted.double.\nstring.quoted.other.\nstring.quoted.single\nstring.quoted.triple.\nstring.regexp.\nstring.unquoted.heredoc.\nsupport.class.\nsupport.constant.\nsupport.function.\nsupport.other.\nsupport.type.\nsupport.variable.\ntext.html.\ntext.plain.\ntext.xml.\nvariable.language.\nvariable.other.predefined.\nvariable.other.readwrite.global.\nvariable.other.register.\nvariable.parameter.\n",
  fallbackInput: "scope",
  input: "none",
  keyEquivalent: "",
  name: "Scope Completion",
  output: "afterSelectedText",
  scope: 
   "string.quoted.single.scope.tm-grammar -punctuation.definition.string.begin, string.quoted.single.scope.root.tm-grammar -punctuation.definition.string.begin,  string.quoted.single.include.tm-grammar -punctuation.definition.string.begin, string.quoted.double.scope.tm-grammar -punctuation.definition.string.begin, string.quoted.double.scope.root.tm-grammar -punctuation.definition.string.begin,  string.quoted.double.include.tm-grammar -punctuation.definition.string.begin",
  uuid: "DF2093BA-EA37-4546-9ADA-C17A13CEBDA9"},
 {beforeRunningCommand: "nop",
  command: 
   "# this will compare the current document against the last\n# version checked out from subversion, but will do it in\n# the pretty-printed format (via pl)\n\npl|diff -u <(\"${TM_SVN:-svn}\" cat \"$TM_FILENAME\"|pl) -\n",
  input: "document",
  name: "Show Changes (for XML Property List)",
  output: "openAsNewDocument",
  scope: "text.xml.plist",
  uuid: "275BF397-2458-4F2F-B0CE-5CDF68256B69"},
 {beforeRunningCommand: "nop",
  command: "tr <<< \"$TM_SCOPE\" ' ' '\\n'",
  input: "none",
  keyEquivalent: "^P",
  name: "Show Scope",
  output: "showAsTooltip",
  uuid: "48976460-B5A4-11D9-87C9-000D93589AF6"},
 {beforeRunningCommand: "nop",
  beforeRunningScript: "nop",
  captureFormatString: "(1?$2:<nop>)",
  capturePattern: "(^TM_(.*)$)?",
  command: "env|grep ^TM_|sort",
  input: "none",
  keyEquivalent: "^@P",
  name: "Show TM_* Variables",
  output: "showAsTooltip",
  standardInput: "selectedText",
  standardOutput: "separateWindow",
  uuid: "DA0A4E77-5F16-11D9-B9C3-000D93589AF6"}]
